 1. return filtered list

    int[] nums = {1, 2, 3, 4, 5, 6};
    var oddNums = (from n in nums where (n % 2) == 0 select n);
    return oddNums;

2. return filtered list using context.Users

    var users = _context.Users;
    IEnumerable<User> usersShortName = (from us in users where us.Firstname.Length == 3 select us);
    return usersShortName;

3.  !!! query works only with IEnumerable<dt>, if List<dt>, need extension of Enumerable

    List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6, 7};
    IEnumerable<int> EvenNums = Enumerable.Where(Nums, n => n % 2 == 0);
    foreach (int n in EvenNums){
        Console.WriteLine(n);
    }    

4. same as above but without extension, using original IEnumerabl

    IEnumerable<int> Nums = new List<int> {1, 2, 3, 4, 5, 6, 7};
    IEnumerable<int> EvenNums = Nums.Where( n => n % 2 == 0);
    foreach (int n in EvenNums){
        Console.WriteLine(n);
    }   

5. min
        a. c#
            int[] Nums = {1, 2, 3, 4, 5, 6};
            int? res = null;
            foreach (int n in Nums){
                if(!res.HasValue || n < res){
                    res = n;
                }
            }
            Console.WriteLine(res);
         
            
        b. LINQ
            int[] Nums = {1, 2, 3, 4, 5, 6};
            int res = Nums.Min();
            
        
5. min even number LINQ

    int[] Nums = {1, 2, 3, 4, 5, 6};
    int MinEven = Nums.Where(n => n % 2 == 0).Min();
    
6. max LINQ   .Max()

7. sum 
    a. c#
        int[] Nums = {1, 2, 3, 4, 5, 6};
        int sum = 0;
        foreach(int n in Nums){
            sum += n;
        }
        return sum;
    
    b. LINQ
        int[] Nums = {1, 2, 3, 4, 5, 6};
        int res = Nums.Sum();
        return res;
    
8. arr length
    a. c#
        int[] Nums = {1, 2, 3, 4, 5, 6};
        int count = 0;
        foreach(int n in Nums){
            count += 1;
        }
        return count;
        
    b. LINQ
        int[] Nums = {1, 2, 3, 4, 5, 6};
        int count = Nums.Count();
        return count;
        
9. average
    a. c#
        int[] Nums = {1, 2, 3, 4, 5, 6};
        double? sum = 0;
        int count = 0;
        double? res = 0;
        foreach(int n in Nums){
            sum += n;
            count += 1;
        }
        res = sum / count;
        return res;
    
    b. LINQ
        int[] Nums = {1, 2, 3, 4, 5, 6};
        double res = Nums.Average();
        return res;
        
10. from string array find shortest str and print number of chars in it and longest str and print number of chars in it
    a. c#
        string[] arr = {"Slavik", "Carlos", "Lena", "Adrian", "Willy", "John", "Vyacheslav", "TJ"};
        int? res = null;
        foreach(string s in arr){
            if(!res.HasValue || s.Length < res){
                res = s.Length;
            }
        }
        Console.WriteLine("shortest name has {0} chars", res);
        return res;
        
    b. LINQ
        string[] arr = {"Slavik", "Carlos", "Lena", "Adrian", "Willy", "John", "Vyacheslav", "TJ"};
        int minCount = arr.Min(x => x.Length);
        int maxCount = arr.Max(x => x.Length);
        
11. convert string array into single string of items separated by comma, without comma after last item

    a. c#
        string[] arr = {"Slavik", "Carlos", "Lena", "Adrian", "Willy", "John", "Vyacheslav", "TJ"};
        string res = string.Empty;
        foreach(string s in arr){
            res += s + ", ";
        }
        int lastIndes = res.LastIndexOf(",");
        res = res.Remove(lastIndex);
        return res;
        
    b. LINQ
        string[] arr = {"Slavik", "Carlos", "Lena", "Adrian", "Willy", "John", "Vyacheslav", "TJ"};
        string res = arr.Aggregate((a, b) => a + ", " + b);  1st and 2nd els -> 1st + 2nd and 3rd....
        return res;

12. multiply each number of array with LINQ

    int[] Nums = {1, 2, 3, 4, 5, 6};
    int res = Nums.Aggregate((a, b) => a * b);
    return res;

13. multiply each number of array starting with constant number 10

    int[] Nums = {1, 2, 3, 4, 5, 6};
    int res = Nums.Aggregate(10, (a, b) => a * b);
    return res;

14. from int array return even nums with LINQ

    a. Where without Func
        List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
        IEnumerable<int> evenNums =  Nums.Where(x => x % 2 == 0);
        foreach(int n in evenNums){
            Console.WriteLine(n);
        }
            
    b. Where with Func
        List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
        Func<int, bool> predicate = x => x % 2 == 0;
        IEnumerable<int> evenNums =  Nums.Where(predicate);
        foreach(int n in evenNums){
        Console.WriteLine(n);
        }
                
    c. Where with function
        List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
        
        IEnumerable<int> evenNums =  Nums.Where(n => isEven(n));
        foreach(int n in evenNums){
        Console.WriteLine(n);
        }           
        
            (in separate function):
                private static bool isEven(int num){
                    if(num % 2 == 0){
                        return true;
                    }
                    else {
                        return false;
                    }
                } 
                or return num % 2 == 0   
        
    d. using SQL syntax
            List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
            IEnumerable<int> evenNums = from n in Nums where n % 2 == 0 select n;
            return evenNums;
    
15. if need Where with index, use Select (from int array return el - index)
    
        List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
        var res = Nums.Select((n, i) => new { Number = n, Index = i});
            for anonymous types use var, unknown dt
        foreach(var el in res){
            Console.WriteLine(el.Number + " - " + el.Index);
        }
        
16. see #15, but even nums

    List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
    var res = Nums.Select((n, i) => new { Number = n, Index = i}).Where(x => x.Number % 2 == 0);
            for anonymous types use var, unknown dt
    foreach(var el in res){
            Console.WriteLine(el.Number + " - " + el.Index);
    }
       
17. see #16 but return only indexes of all even numbers

    List<int> Nums = new List<int> {1, 2, 3, 4, 5, 6};
    var res = Nums.Select((n, i) => new { Number = n, Index = i}).Where(x => x.Number % 2 == 0).Select(x => x.Index);
        for anonymous types use var, unknown dt
    foreach(int el in res){
        Console.WriteLine(el);
    }    
********* One To Many in Entity FW ***********
********* Example 1 **************************

    1. Models
            One:     public ICollection<Order> Orders {get; set;}
            Many:    public int CustomerId {get; set;}
                     public Customer Customer {get; set;}
    2. seed data (DataContext.cs)
        public class DataContext : DbContext
        {
            public DataContext(DbContextOptions<DataContext> options) : base(options) { }

            public DbSet<User> Users { get; set; }
            public DbSet<Lg> Lgs { get; set; }        
            public DbSet<A> As { get; set; }       
            public DbSet<B> Bs { get; set; }       
            
            
            
            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {            
                modelBuilder.Entity<UserLg>().HasKey(x => new { x.UserId, x.LgId }); 
                modelBuilder.Entity<A>()   
                .HasData(
                    new A { Id = 1, AName = "A1", AFig = 10},    
                    new A { Id = 2, AName = "A2", AFig = 20}                   
                );
                modelBuilder.Entity<B>()   
                .HasData(
                        new B { Id = 1, BName = "B1", BFig = 10, BGen = "M", AId = 1},    
                        new B { Id = 2, BName = "B2", BFig = 20, BGen = "M", AId = 1},   
                        new B { Id = 3, BName = "B3", BFig = 30, BGen = "M", AId = 1},   
                        new B { Id = 4, BName = "B4", BFig = 40, BGen = "F", AId = 2},   
                        new B { Id = 5, BName = "B5", BFig = 50, BGen = "F", AId = 2}  
                        );                  
            }
        }
    3. Configure DB (Startup.cs) in ConfigureSeervices
        services.AddDbContext<DataContext>(x => {                 
                 x.UseMySql("Server=localhost;Port=3306;Database=aaaa;User=root;Password=gerKanuk55");
            }); 
    4. >>dotnet ef migrations add newMigration
       >>dotnet ef database update
****************************************************     
18. print b.BName of males (BGem == "M") from As with AName "A1" and "A2"  (A to B as One to Many)

        var aa = _context.As;
        IEnumerable<A> aaa = aa.Include(x => x.Bs).Where(x => x.AName == "A1" || x.AName == "A2");

        foreach(A a in aaa){
            IEnumerable<B> bb = a.Bs.Where(x => x.BGen == "M");
            foreach(B b in bb){
                Console.WriteLine("B Name = " + b.BName);                    
            }
        }
19. Print ids of all bs  (extract one col)

        IEnumerable<int> bs = _context.Bs.Select(x => x.Id);
        foreach(int b in bs){
            Console.WriteLine(b);
        }
20. Print: BName - BGen for all bs (extract > 1 col)

        var bs = _context.Bs.Select(x => new {Name = x.BName, Gender = x.BGen});
        foreach(var b in bs){
            Console.WriteLine(b.Name + " - " + b.Gender);
        }

21. Print: BName - BFig - Bonus (only if BFig > 20, Bonus is 15% of BFig) !!! a * 0.15 (a must be double)

     var bs = _context.Bs.Where(x => x.BFig > 20).Select(x => new {Name = x.BName, Salary = x.BFig, Bonus = x.BFig * .15});
    foreach(var b in bs){
        Console.WriteLine(b.Name + " - " + b.Salary + " - " + " - " + b.Bonus);
    }

!!! outerArr.SelectMany(x => x);   where x is inner arr or string -> returns els of x one by one
                                   return all inner arrays els from all outer array flattened
                                   inner array in x => x.Bs is x.Bs
                                   all courses of student A + all courses of student B -> all courses

22. Pring BName for all bs of all as  (as -> bs -> B.Name) 
    a. LINQ method

        var aa = _context.As;
        IEnumerable<B> bs = aa.SelectMany(a => a.Bs);
        foreach(B b in bs){
            Console.WriteLine(b.BName);
        }

    b. LINQ SQL syntax

        var aa = _context.As;
        IEnumerable<B> bs = from a in aa from b in a.Bs select b;
        foreach(B b in bs){
            Console.WriteLine(b.BName);
        }
23. 2 strings -> break into chars, flatten into one chunk, print all char per line

    a. LINQ method

        string[] str = {"very", "good"};
        IEnumerable<char> res = str.SelectMany(x => x);
        foreach(char el in res){
            Console.WriteLine(el);
        }
    b. LINQ SQL syntax

        string[] str = {"very", "good"};
        IEnumerable<char> res = from s in str from ch in s select ch;
        foreach(char el in res){
            Console.WriteLine(el);
        }

24. from bs print all distinct BFig

        var bs = _context.Bs;
        IEnumerable<double> res = from b in bs select b.BFig distinct;

        foreach(double el in res){
            Console.WriteLine(el);
        }

        !!! or  IEnumerable<double> res = (from b in bs select b.BFig).Distinct();

25. print   A1 - B1    where A1 and B1 are AName and BName 
            A1 - B2
            A1 - B3
            A2 - B4
            A2 - B5
            A2 - B6
    !!!see #22 but here need access to outer array as well

    a. LINQ method 
        
        var aa = _context.As;
        var res = aa.SelectMany(a => a.Bs, (a, b) => new { AName = a.AName, BName = b.BName});
        foreach(var r in res){
            Console.WriteLine("{0} - {1}", r.AName, r.BName);
        }
    b. LINQ SQL syntax

        var aa = _context.As;
        var res = from a in aa from b in a.Bs select new {AName = a.AName, BName = b.BName};
        foreach(var r in res){
            Console.WriteLine("{0} - {1}", r.AName, r.BName);
        }
26. Select vs SelectMany: print BName for all Bs of all As

    a. Select:

        var aa = _context.As;
        IEnumerable<ICollection<B>> bsChunks = aa.Select(a => a.Bs);
        foreach(ICollection<B> bs in bsChunks){
            foreach(B b in bs){
                Console.WriteLine(b.BName);
            }
        }
    b. SelectMany

        var aa = _context.As;
        IEnumerable<B> bs = aa.SelectMany(a => a.Bs);        
        foreach(B b in bs){
            Console.WriteLine(b.BName);
        }

27. ascending order of AName of all As
    a. LINQ method

        var aa = _context.As;
        IEnumerable<A> res =  aa.OrderBy(a => a.AName);          
        foreach(A a in res){
            Console.WriteLine(a.AName);
        }

    b. LINQ SQL syntax

        var aa = _context.As;
            IEnumerable<A> res =  from a in aa orderby a.AName ascending select a;              
            foreach(A a in res){
                Console.WriteLine(a.AName);
            }
        !!! ascending optional here

    !!! .OrderByDescending(a => a.AName)   .... descending

28. print       10      P       1     where col1 is AFig, col2 is AName, col3 is Id
                10      X       7
                10      Y       5
                20      J       2
                20      Z       6
                30      F       3
                30      G       4

        !!! order 1st by AFig, then within each new group order by AName (ascending)

    a. LINQ method

        var aa = _context.As;
        IEnumerable<A> res =  aa.OrderBy(a => a.AFig).ThenBy(a => a.AName);        
        
        foreach(A a in res){
            Console.WriteLine(a.AFig + "\t" + a.AName + "\t" + a.Id);
        }      
            
    b. LINQ SQL syntax, first order by AFig, then by AName and then descending by Id
        10      P       7
        10      P       1
        10      Y       5
        20      J       2
        20      X       6
        30      F       3
        30      G       4

        var aa = _context.As;
        IEnumerable<A> res =  from a in aa orderby a.AFig, a.AName, a.Id descending select a;          
        foreach(A a in res){
            Console.WriteLine(a.AFig + "\t" + a.AName + "\t" + a.Id);
        }
            
    !!! .ThenByDescending(a => a.AName)

29. print first 3 elements of string[]
    
    a. LINQ method

        string[] arr = {"a", "bs", "abc", "d", "lala"};
        IEnumerable<string> res = arr.Take(3);
        foreach(string s in res){
            Console.WriteLine(s);
        }
    b. LINQ SQL syntax

        string[] arr = {"a", "bs", "abc", "d", "lala"};
        IEnumerable<string> res = (from s in arr select s).Take(3);
        foreach(string s in res){
            Console.WriteLine(s);
        }
    !!! .Skip(3)  skips first 3 elements     

30. print elements of string[] from beginning as long as el's length <= 3, stop if condition false

    string[] arr = {"a", "bs", "abc", "d", "lala"};
    IEnumerable<string> res = arr.TakeWhile(x => x.Length <= 3);
    foreach(string s in res){
        Console.WriteLine(s);
    }
    !!! .SkipWhile(3)  skip if condition true and print when condition false
            
31. paging 

    IEnumerable<A> aa = _context.As;
    Console.WriteLine("Enter Page Number = 1, 2, 3 or 4");
    int pageNum = 0;
    if(int.TryParse(Console.ReadLine(), out pageNum)){
        if(pageNum >= 1 && pageNum <=4){
            int pageSize = 3;
            IEnumerable<A> res = aa.Skip((pageNum - 1) * pageSize).Take(pageSize);
            Console.WriteLine("Displaying Page " + pageNum);
            foreach(A a in res){
                Console.WriteLine(a.Id + "\t" + a.AName + "\t" + a.AFig);

            }
        } else {
            Console.WriteLine("Page number must be integer between 1 and 4");
        }
    } else {
            Console.WriteLine("Page number must be integer between 1 and 4");
    }

32. print    1       P       10  where col1 is id, col2 is AName, col3 is AFig, only if AFig == 10
             5       Y       10
             7       P       10
        !!! with LINQ SQL syntax
     
        IEnumerable<A> aa = _context.As;
        IEnumerable<A> res = from a in aa where a.AFig == 10 select a;
        foreach(A a in res){
            Console.WriteLine(a.Id + "\t" + a.AName + "\t" + a.AFig);
        }
        !!! query executed in foreach loop, defered / lazy execution: Select, Where, Take, Skip...


        var aa = _context.As;
            var aaa = aa.ToList();
            IEnumerable<A> res = from a in aaa where a.AFig == 10 select a;
            aaa.Add( new A() {Id = 8, AName = "ZZ", AFig = 10});
            foreach(A a in res){
                Console.WriteLine(a.Id + "\t" + a.AName + "\t" + a.AFig);
            }
        !! ZZ included in list because execution defered
        !!! if query -> ToList()  -> immediate execution:

        var aa = _context.As;
            var aaa = aa.ToList();
            IEnumerable<A> res = (from a in aaa where a.AFig == 10 select a).Tolist();
            aaa.Add( new A() {Id = 8, AName = "ZZ", AFig = 10});
            foreach(A a in res){
                Console.WriteLine(a.Id + "\t" + a.AName + "\t" + a.AFig);
            }
        !! ZZ not included

    !!! immediate operators: Count, Average, Min, Max, ToList, ...
        lazy operators: Select, Where, Take, Skip, ...

33. from int[] print List<int>

        [] arr = {1, 2, 3, 4};
        List<int> res = arr.ToList();
        foreach(int n in res){
            Console.WriteLine(n);
        }

34. (LINQ SQL syntax) from List<int> in ascending order get IEnumerable<int> -> convert to int[]
                print each el
        List<int> list = new List<int> {1, 2, 20, 15, 21, 3};
        int[] res = (from n in list orderby n ascending select n).ToArray();
        foreach(int n in res){
            Console.WriteLine(n);
        }


!!! Dictionary is alt in js: array of objects, each obj with one property only {Key, Value}
            !!! Keys must be unique, if some objs have identical Keys, use Lookup

35. from list  (set...) of objects -> Dictionary<int, string>
    output: 1       P  where col1 is AId, col2 is AName, as Dictionary; col1 and col2 accessed as Key-Value
            2       J
            3       F
            4       G
        var aa = _context.As;
        List<A> aaa = aa.ToList();
        Dictionary<int, string> res =  aaa.ToDictionary(x => x.Id, x => x.AName);
        foreach(KeyValuePair<int, string> kvp in res){
            Console.WriteLine(kvp.Key + "\t" + kvp.Value);
        }
    !!! will also work with aa (DbSet<A>), without converting to aaa (List<A>)

36. see #35, but print  1       P       10   where col3 is AFig,  col1 accessed as Key, col2 and col3 accessed via A
                        2       J       20
                        3       F       30
                        4       G       30

        var aa = _context.As;
        List<A> aaa = aa.ToList();
        Dictionary<int, A> res =  aaa.ToDictionary(x => x.Id);
        foreach(KeyValuePair<int, A> kvp in res){
            Console.WriteLine(kvp.Key + "\t" + kvp.Value.AName + "\t" + kvp.Value.AFig);
        }

37. print   10                        where col1 is AFig, col2 is AName, col3 is AFig
                    P       10
                    Y       10
                    P       10
            20
                    J       20
                    X       20
            30
                    F       30
                    G       30
        !!! group As based on AFig

        var aa = _context.As;
        var asByFig = aa.ToLookup(x => x.AFig);   //converts to Lookup (like Dictionary with not unique or unique Keys)        
        foreach(var kvp in asByFig){
            Console.WriteLine(kvp.Key);
            foreach(var a in asByFig[kvp.Key]){
                Console.WriteLine("\t" + a.AName + "\t" + a.AFig);
            }
        }
38. convert ArrayList (add ints) into IEnumerable<int> and pring each el

        ArrayList list = new ArrayList();
        list.Add(1);
        list.Add(2);
        list.Add(3);

        IEnumerable<int> res = list.Cast<int>();
        foreach(int n in res){
            Console.WriteLine(n);
        }

!!! with Cast<int>, if ArrayList contains non-int value, exception thrown

39. see #38, but ArrayList contains int els and string el, print only ints

        ArrayList list = new ArrayList();
        list.Add(1);
        list.Add(2);
        list.Add(3);
        list.Add("abc");

        IEnumerable<int> res = list.OfType<int>();
        foreach(int n in res){
            Console.WriteLine(n);
        }
40. print   B3      30      M   where col1 is BName, col2 is BFig, col3 is BGen 
            B2      20      M
            B1      10      M
        !!! only M (Males), in decending order based on BFig, only first 3 (top 3 male Bs by salary)

        var bs = _context.Bs;
        var res = bs.Where(x => x.BGen == "M").OrderByDescending(x => x.BFig).Take(3);
        foreach(var b in res){
            Console.WriteLine(b.BName + "\t" + b.BFig + "\t" + b.BGen);
        }
        !!! to convert DbSet<B> to IEnumerable<B>, use .AsEnumerable()

        var bs = _context.Bs;
        IEnumerable<B> res = bs.AsEnumerable().Where(x => x.BGen == "M").OrderByDescending(x => x.BFig).Take(3);
        foreach(var b in res){
            Console.WriteLine(b.BName + "\t" + b.BFig + "\t" + b.BGen);
        }
    !!! always use .AsEnumerable to query _context.Bs
        query executed before .AsEnumerable (without it, it will execute all the way)
        Linq-to-Sql then Linq-to-Objects, moves query processing to the client side

41. print   P - 1  where col1 is AName, col2 is how many As with this AName
            J - 1
            F - 2
            G - 3

    a. LINQ method

        var aa = _context.As;
        var groups = aa.ToList().GroupBy(x => x.AName);
        foreach(var group in groups){
            Console.WriteLine("{0} - {1}", group.Key, group.Count());
        }
        ?.GroupBy
    !!! to only include male (AGen) As:  .Count(x => x.AGen == "M")

    b. LINQ SQL syntax

        var aa = _context.As;
        var aaa = aa.ToList();
        var groups = from a in aaa group a by a.AName;
        foreach(var group in groups){
            Console.WriteLine("{0} - {1}", group.Key, group.Count());
        }

42. print   P - 1 - 10   where col1 is AName, col2 is # of As with this AName, col3 is maximum AFig within this group
            J - 1 - 20
            F - 2 - 30
            G - 3 - 30

        var aa = _context.As;
        var aaa = aa.ToList();
        var groups = from a in aaa group a by a.AName;
        foreach(var group in groups){
            Console.WriteLine("{0} - {1} - {2}", group.Key, group.Count(), group.Max(x => x.AFig));
        }

    !!! total amount of AFig for each group:  .group.Sum(x => x.AFig)

43. print   IT - 3                   // IT is BDep, 3 is # of Bs in this BDep
            -------------------
            B1      10               // B1 is BName, 10 is BFig        
            B4      40
            B5      50


            HR - 2
            -------------------
            B2      20
            B3      30


    var bs = _context.Bs;
    var bb = bs.ToList();
    var groups = from b in bb group b by b.BDep ;
    foreach(var group in groups){
        Console.WriteLine("{0} - {1}", group.Key, group.Count());   
        Console.WriteLine("-------------------");             
        foreach(var b in group){
            Console.WriteLine(b.BName + "\t" + b.BFig);
        }
        Console.WriteLine(); Console.WriteLine();
    }

44. see #43, but order alphabetically by BDep, and within each group by BName

    print   HR - 3
            -------------------
            D       20                // D is BName
            E       30
            H       30


            IT - 3
            -------------------
            C       10
            F       40
            G       50

    var bs = _context.Bs;
    var bb = bs.ToList();
    var groups = bb.GroupBy(x => x.BDep).OrderBy(g => g.Key).Select(g => new {Key = g.Key, Bs = g.OrderBy(x => x.BName)});
    /* (LINQ SQL syntax)
        var groups = from b in bb group b by b.BDep into eGroup orderby eGroup.Key 
                    select new {Key = eGroup.Key, Bs = eGroup.OrderBy(x => x.BName)};
    */
    
    foreach(var group in groups){
        Console.WriteLine("{0} - {1}", group.Key, group.Bs.Count());   
        Console.WriteLine("-------------------");             
        foreach(var b in group.Bs){
            Console.WriteLine(b.BName + "\t" + b.BFig);
        }
        Console.WriteLine(); Console.WriteLine();
    }

45. Group list by > 1 col value (same val for > 1 row of these cols) using GroupBy
    !!! first group by BDep (outer group) then by BGen (inner group); 
        order by BDep within outer group, by BName within inner group

    Department: HR, Gender: Fs, number: 1
    ----------------------
    Name: H, Gender: F, Department: HR


    Department: HR, Gender: Ms, number: 2
    ----------------------
    Name: D, Gender: M, Department: HR


    Name: E, Gender: M, Department: HR


    Department: IT, Gender: Fs, number: 2
    ----------------------
    Name: F, Gender: F, Department: IT


    Name: G, Gender: F, Department: IT


    Department: IT, Gender: Ms, number: 1
    ----------------------
    Name: C, Gender: M, Department: IT


    var bb = _context.Bs;
    var bs = bb.ToList();
    var newList = bs.GroupBy(x => new {x.BDep, x.BGen})
                    .OrderBy(g => g.Key.BDep).ThenBy(g => g.Key.BGen)
                    .Select(g => new {DepName = g.Key.BDep, Gen = g.Key.BGen, Bs = g.OrderBy(x => x.BName)});
    foreach(var gr in newList){
        Console.WriteLine("Department: {0}, Gender: {1}s, number: {2}", gr.DepName, gr.Gen, gr.Bs.Count());
        Console.WriteLine("----------------------");
        foreach(var b in gr.Bs){
            Console.WriteLine("Name: {0}, Gender: {1}, Department: {2}", b.BName, b.BGen, b.BDep);
            Console.WriteLine(); Console.WriteLine();
        }
    }
!!! without ordering: (see Bs = g, where g is all props of grouped obj, including g.Key)
    but better always order
    

    var bb = _context.Bs;
    var bs = bb.ToList();
    var newList = bs.GroupBy(x => new {x.BDep, x.BGen})                            
                    .Select(g => new {DepName = g.Key.BDep, Gen = g.Key.BGen, Bs = g});
    foreach(var gr in newList){
        Console.WriteLine("Department: {0}, Gender: {1}s, number: {2}", gr.DepName, gr.Gen, gr.Bs.Count());
        Console.WriteLine("----------------------");
        foreach(var b in gr.Bs){
            Console.WriteLine("Name: {0}, Gender: {1}, Department: {2}", b.BName, b.BGen, b.BDep);
            Console.WriteLine(); Console.WriteLine();
        }
    }
46. print   HR             // where HR is A.ADep, C is B.BName    ----- Hierarchical representation
                C
                D
                E

            IT
                F
                G
                H
            IT

            HR

            IT

    !!! using GroupJoin    

    a.  LINQ 
        var aa = _context.As.ToList();
        var bs = _context.Bs.ToList();    
        var bsByA = aa.GroupJoin(bs, a => a.Id, b => b.AId,  (a, bs) => new {A = a, Bs = bs});
        foreach(var a in bsByA){
            Console.WriteLine(a.A.ADep);
            foreach(var b in a.Bs){
                Console.WriteLine(" " + b.BName);
            }
            Console.WriteLine();
        }

    b. LINQ SQL: 
        var bsByA = from a in aa join b in bs on a.Id equals b.AId into g select new {A = a, Bs = g};
    !!! all a.A.ADep linked to B and not linked to B included (to include only matching els use inner join)

47. print   HR      C  where col1 is ADep, col2 is BName (B associated with this A) ---flat representation
            HR      D
            HR      E
            IT      F
            IT      G
            IT      H
    !!! use Join, inner join (sql)
    a. LINQ method

        var aa = _context.As.ToList();
        var bs = _context.Bs.ToList();    
        var bsByA = aa.Join(bs, a => a.Id, b => b.AId,  (a, b) => new {A = a, B = b});           
        foreach(var el in bsByA){
            Console.WriteLine(el.A.ADep + "\t" + el.B.BName);                
        }        

    b. LINQ SQL syntax
        
        var aa = _context.As.ToList();
        var bs = _context.Bs.ToList();    
        var bsByA = from a in aa join b in bs on a.Id equals b.AId select new {A = a, B = b};        
        foreach(var el in bsByA){
            Console.WriteLine(el.A.ADep + "\t" + el.B.BName);                
        }           
            
!!! GroupJoin vs Join (inner join): 
    1. GroupJoin -> hierarchical representation, Join -> flat representation
    2. GroupJoin -> returns also As that do not have any Bs, Join only returns associated As to Bs
    3. GroupJoin res requires 2 loops: 1st loop for To What (aa, or result of joining) is group-joined, 2nd for What (bs) is joined
            Join requires one loop for To What is group-joined (aa, or result of joining)

48. list.First()
    list.First(predicate)  -> exc if list was empty
    list.FirstOrDefault(predicate)  -> no exc if list was empty
            !!! default is el's default, if int -> 0, bool -> false, rest -> null
    list.Last()
    list.LastOrDefault()

    list.ElementAt(5) ->  exc if no element at index 5
    list.ElementAtDefault(5) -> default value if no element at index 5

    list.Single(predicate) -> if > 1 match -> error
    list.SingleOrDefault(predicate)  -> returns default if no match but if > 1 match -> error

    list.DefaultEmpty() -> returns IEnumerable<int> res with all vals or if no vals -> def val (0 for int)
    list.DefaultEmpty(100) -> if no vals -> returns 100

    ar1.Union(ar2) -> ar1 + ar2 distinct
    ar1.Concat(ar2) -> ar1 + ar2 (also if same vals)

    ar.Any()  -> true if at least 1 with val
    ar.Any(predicate) -> true if at least 1 el satisfies predicate

    ar.Contains(3) -> true if at least 1 el has val 3
    ar.Contains("la", StringCompararer.OriginalIgnoreCase) -> ignores Case

    ar.SequenceEqual(ar2) -> true if same # of els, same order, same vals
    ar.SequenceEqual(ar2, StringCompararer.OriginalIgnoreCase);

     


***********************************************************************************************************
***************************** SUMMERY *********************************************************************
Abbrev: IEnumerable<A> as IE<X>
 
1. filter IE -> filtered list of elements

    xx.Where( n => n % 2 == 0)  
    from x in xx where x.Name.Length == 3 select x

2. access 1 col ---> new list of objs, access vals and indexes

    xx.Select((n, i) => new { Number = n, Index = i});   
    from x in xx select new {....}

3. Select - Where  or Where - Select  in any order ok

4. to get get chunks of bs (of each of aa) -> flatten to one list

     aa.SelectMany(x => x.Bs)  
     from a in aa from b in a.Bs select b;

5. to access > 1 cols -> new list of objects: 

     bs.Select(x => new {Name = x.BName, Gender = x.BGen});

6. to create new temporary col (here Bonus)

    bs.Select(x => new {Name = x.BName, Bonus = x.BFig * .15});

7. to access and return cols from aa and bs at the same time

    aa.SelectMany(a => a.Bs, (a, b) => new { AName = a.AName, BName = b.BName});
    from a in aa from b in a.Bs select new {AName = a.AName, BName = b.BName};

8. list -> same list but reordered

    aa.OrderBy(a => a.AName);                          //.OrderByDescending(a => a.AName);
    from a in aa orderby a.AName ascending select a; 

    aa.OrderBy(a => a.AFig).ThenBy(a => a.AName); 
    from a in aa orderby a.AFig, a.AName, a.Id ascending select a;  

9. use of dictionary?????

    Dictionary<int, string> res =  aa.ToDictionary(x => x.Id, x => x.AName);
        foreach(KeyValuePair<int, string> kvp in res){
            .... kvp.Key .... kvp.Value  .....
        }
        aa.ToDictionary(x => x.Id, x => x.AName)  
                -> each iter is KeyValuePair<int, string>, where int is kpv.Key (x.Id)
                                                                 string is kpv.Value (x.AName)
        aa.ToDictionary(x => x.Id) 
                -> each iter is KeyValuePair<int, A> kvp, where int is kpv.Key (x.Id)
                                                                A is kpv.Value -> kpv.Value.AName

10. Group by col's val (same for > 1 row) using ToLoopup

    aa.ToLookup(x => x.AFig)  ->  list of objects with Key is x.AFig, Value is grouped list (chunk)
                                          each object -> obj.Key is x.AFig
                                                         list[object.Key] -> chunk

       foreach(var kvp in asByFig){
            Console.WriteLine(kvp.Key);
            foreach(var a in asByFig[kvp.Key]){
                Console.WriteLine("\t" + a.AName + "\t" + a.AFig);


11. Group list by 1 col's value (same val for > 1 row) using GroupBy

        aa.ToList().GroupBy(x => x.AName)  -> list of chunks, each chunk: chunk.Key is x.AName
                                                                          chunk.Prop  -> any prop of grouped els
                                                                          chunk.Max()
                                                                          chunk.Count()
                   ex. el of chunk:  {Key: x.AName, AName: "Slavik", AFig: 40}                             
        from a in aa group a by a.AName;

        !!! expression on right side of x=>  is g.Key

12. Group list, then order chunk.Key and elements within chunk (LINQ SQL)

            a. group by some col -> list of chunks    (name this group, ex into eGroup)
            b. order by chunk's Key (by which was grouped)
            c. create new object with one prop (PropBs) as grouped chunk (by some col) -> list of objects
            d. iterate list of objects -> each object: access to grouped chunk via obj's prop
                                                                ex. chunk.PropBs.Count();
            e. iterate each chunk.PropBs -> each (now ordered) chunk: chunk.ColName 
13. group by 2 cols

    1) bs.GroupBy(x => new {x.BDep, x.BGen})  ->
        returns list of objects, each object has Key prop (here BDep) 
            and rest of Props  (here for B)
    2) .Select(g => new {DepName = g.Key.BDep, Gen = g.Key.BGen, Bs = g}) -> 
            collect rest of Props into Bs of new object, later can itarate to print or first order
          !!! Bs = g.OrderBy(x => x.BName)   -> orders rest of props

************************************************************************************************************
*************************** PRACTICE ***********************************************************************
    1 - 20 methods used:
        x.HasValue; arr.LastIndexOf("la");  Remove(i); 
        Func<int, bool> predicate = x => x % 2 == 0;
        Nums.Aggregate(10, (a, b) => a * b);
        Nums.Select((n, i) => new { Number = n, Index = i});

1. with LINQ query from int[] return odd numbers
2. with LINQ query from context.Users return users whose Name is 3 chars long
3  with LINQ query from List<int> return odd numbers
4. with LINQ query from IEnumerable<int> return odd numbers
5. from int[] return min with (a) c#  (b) LINQ method
6. from int[] return max with LINQ method
7. from int[] return sum with (a) c#  (b) LINQ method
8. from int[] return arr length with (a) c#  (b) LINQ method
9. from int[] return average number (as double) with (a) c#  (b) LINQ method
10. from string[] find shortest str and print number of chars in it and longest str and print number of chars in it
        with (a) c#  (b) LINQ method
11. convert string[] into single string of items separated by comma, without comma after last item
        with (a) c#  (b) LINQ method
12. multiply each number of int[] with LINQ method
13. multiply each number of int[] starting with constant number 10, with LINQ method
14. from int[] return even nums with LINQ
    a. Where with simple lambda
    b. Where with Func
    c. Where with external function
    d. with LINQ SQL syntax
15. from int[] return el - index for each iteration, LINQ method
16. from int[] return el - index for each iteration, where el is even number, LINQ method
17. from int[] return indeces for even numbers
************

    configure db, models, A (one) B (many)

************
18. print b.BName of males (BGem == "M") from As with AName "A1" and "A2"  (A to B as One to Many)
19. Print ids of all bs  (extract one col)
20. Print: BName - BGen for all bs (extract > 1 col)
21. Print: BName - BFig - Bonus (only if BFig > 20, Bonus is 15% of BFig) !!! a * 0.15 (a must be double)
22. Pring BName for all bs of all as  (as -> bs -> B.Name) ----LINQ, SQL
23. 2 strings -> break into chars, flatten into one chunk, print all char per line ---LINQ, SQL
24. from bs print all distinct BFig

25. print   A1 - B1    where A1 and B1 are AName and BName 
            A1 - B2
            A1 - B3
            A2 - B4
            A2 - B5
            A2 - B6

    !!!see #22 but here need access to outer array as well ------ LINQ, SQL

26. Select vs SelectMany: print BName for all Bs of all As ----- Select vs SelectMany
27. ascending order of AName of all As --- LINQ, SQL

28. print       10      P       1     where col1 is AFig, col2 is AName, col3 is Id
                10      X       7
                10      Y       5
                20      J       2
                20      Z       6
                30      F       3
                30      G       4

        !!! order 1st by AFig, then within each new group order by AName (ascending)
    a. LINQ
    b. LINQ SQL syntax, first order by AFig, then by AName and then descending by Id

        10      P       7
        10      P       1
        10      Y       5
        20      J       2
        20      X       6
        30      F       3
        30      G       4

29. print first 3 elements of string[]  ---- LINQ, SQL;  Take vs Skip
30. print elements of string[] from beginning as long as el's length <= 3, stop if condition false
            TakeWhile vs SkipWhile
31. paging ???

32. print    1       P       10  where col1 is id, col2 is AName, col3 is AFig, only if AFig == 10
             5       Y       10
             7       P       10

        !!! with LINQ SQL syntax;  where executed? 

33. from int[] print List<int>
34. (LINQ SQL syntax) from List<int> in ascending order get IEnumerable<int> -> convert to int[]
                print each el
35. from list  (set...) of objects -> Dictionary<int, string>

    output: 1       P  where col1 is AId, col2 is AName, as Dictionary; col1 and col2 accessed as Key-Value
            2       J
            3       F
            4       G

36. see #35, but print  1       P       10   where col3 is AFig,  col1 accessed as Key, col2 and col3 accessed via A
                        2       J       20
                        3       F       30
                        4       G       30

37. print   10                        where col1 is AFig, col2 is AName, col3 is AFig
                    P       10
                    Y       10
                    P       10
            20
                    J       20
                    X       20
            30
                    F       30
                    G       30

        !!! group As based on AFig

38. convert ArrayList (add ints) into IEnumerable<int> and pring each el
39. see #38, but ArrayList contains int els and string el, print only ints

40. print   B3      30      M   where col1 is BName, col2 is BFig, col3 is BGen 
            B2      20      M
            B1      10      M

        !!! only M (Males), in decending order based on BFig, only first 3 (top 3 male Bs by salary)

41. print   P - 1  where col1 is AName, col2 is how many As with this AName
            J - 1
            F - 2
            G - 3

     --- LINQ, SQL;  modify to only include males (BGen == "M") use Bs 

42. print   P - 1 - 10   where col1 is AName, col2 is # of As with this AName, col3 is maximum AFig within this group
            J - 1 - 20
            F - 2 - 30
            G - 3 - 30

    --- modify: total amount of AFig for each group

43. print   IT - 3                   // IT is BDep, 3 is # of Bs in this BDep
            -------------------
            B1      10               // B1 is BName, 10 is BFig        
            B4      40
            B5      50


            HR - 2
            -------------------
            B2      20
            B3      30

!!!!!!!!!

44. see #43, but order alphabetically by BDep, and within each group by BName

    print   HR - 3
            -------------------
            D       20                // D is BName
            E       30
            H       30


            IT - 3
            -------------------
            C       10
            F       40
            G       50

!!!!!!!!!

45. Group list by > 1 col value (same val for > 1 row of these cols) using GroupBy
    !!! first group by BDep (outer group) then by BGen (inner group); 
        order by BDep within outer group, by BName within inner group

    Department: HR, Gender: Fs, number: 1
    ----------------------
    Name: H, Gender: F, Department: HR


    Department: HR, Gender: Ms, number: 2
    ----------------------
    Name: D, Gender: M, Department: HR


    Name: E, Gender: M, Department: HR


    Department: IT, Gender: Fs, number: 2
    ----------------------
    Name: F, Gender: F, Department: IT


    Name: G, Gender: F, Department: IT


    Department: IT, Gender: Ms, number: 1
    ----------------------
    Name: C, Gender: M, Department: IT
 




