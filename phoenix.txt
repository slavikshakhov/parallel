> mix phx.new proj    
proj> mix setup 

(config/dev.exs) ---- password for postgres  (default database, name is "postgres", "postgres")
proj> mix ecto.create        !!! creates db 
> mix phx.server     (runs on 4000)
!!! > iex -S mix phx.server     (can also debug, rugn iex commands, query db....)

!!! mix phx.new live_view_counter --live --no-ecto  


********************************************************************************************************
def mount(_params, _session, socket) do
  {:ok, assign(socket, :val, 0) }
end

def handle_event("inc", _, socket) do
  {:noreply, update(socket, :val, &(&1 + 1))}
end

def render(assigns) do
    ~L"""
    <div>
      <h1>The count is: <%= @val %></h1>
      <button phx-click="dec">-</button>
      <button phx-click="inc">+</button>
    </div>
    """
  end

!!! :noreply -----  no messages to caller of fun 
!!!  ~L sigil is a macro included when the use Phoenix.LiveView is invoked at the top of the file
_______________________________________________________________________________________________
                            ADD WEBSOCKET (BUILT-IN)

@topic "live"       ------ like global var, channel, acceccible anywhere

def mount(_session, _params, socket) do
    LiveViewCounterWeb.Endpoint.subscribe(@topic)         # subscribe to the channel
    {:ok, assign(socket, :val, 0)}
end

def handle_event("inc", _msg, socket) do
  new_state = update(socket, :val, &(&1 + 1))
  LiveViewCounterWeb.Endpoint.broadcast_from(self(), @topic, "inc", new_state.assigns)
  {:noreply, new_state}
end

!!! self()  ----- current process  (message sent from self() via @topic channel)
    %{"inc" => new_state.assigns}
!!! new_state is an instance of the Phoenix.LiveView.Socket socket
!!! new_state.assigns  --> %{ ....... , val: 1 }    ----- after button clicked val: 1
###############################

#Phoenix.LiveView.Socket<
  assigns: %{
    flash: %{},
    live_view_action: nil,
    live_view_module: LiveViewCounterWeb.Counter,
    val: 1
  },
  changed: %{val: true},
  endpoint: LiveViewCounterWeb.Endpoint,
  id: "phx-Ffq41_T8jTC_3gED",
  parent_pid: nil,
  view: LiveViewCounterWeb.Counter,
  ...
}
##############################

def handle_info(msg, socket) do
  {:noreply, assign(socket, msg.payload)}
end

!!! msg  ----- received message
!!! socket ------  Phoenix.Socke
!!! without  :noreply  --> recursive loop of updates


************************************************************************************************************
************************************************************************************************************
                          PROGRAMMING PHOENIX (BOOK)

DATA FLOW 

  connection |> phoenix 
                  (layers):
                      |> endpoint()     ---- consists of plugs for each req... last plug is router 
                      |> router()
                      |> pipelines()
                      |> controller() 
                            has: |> common_services()   ---- implemented with plug 
                                 |> action()

  connection as req -> conn -> conn -> conn -> as res to front  (plugs)
  .ex --compiled to .beam files (run on Erlang virtual machine)
  .eex  -- Elixir scripts (not to .beam files)

config/config.exs     ----applic wide (logging, endpoints)
      /dev.exs
      /prod.exs
      /test.exs           !!! dev, prod, test --- switch via MIX_ENV
      /prod.secret.exs

config/config.exs   ---- config: hello, HelloWeb.Endpoint
lib/hello_web/endpoint.ex --- plugs for applic (for every req)

M (accesses data) --- V (present data) --- C (coordination between M, C)

***********************************************************************************************************
                              HELLP WORLD APP 
                    load url 
                    print string 

> mix phx.new hello

config/dev.ex  ----username: "postgres" ....  password: "gerK..55" .... database: "postgres" ... 
hello > mix ecto.create  
> mix phx.server  
----
1. ROUTER (router.ex)
   get "/hello", HelloController, :world 

2. CONTROLLER (controllers/hello_controller.ex)

    defmodule HelloWeb.HelloController do
      use HelloWeb, :controller

      def world(conn, _params) do
        render(conn, "world.html")
      end
    end

3. VIEW (views/hello_view.ex)  ---- helps to render template 

    defmodule HelloWeb.HelloView do
      use HelloWeb, :view
    end

4. TEMPLATE (templates/hello/world.html.eex)    !!! .eex 

      <h1>Hello World!</h1>
  -----
  --> live reloading (see 4000 port)

---------------------------------------------------------------------------------
          + PARAMS 

get "/hello/:name", HelloController, :world
----
def world(conn, %{"name" => name}) do
  render(conn, "world.html", name:name)     ----    render(conn, "world.html", [name:name]) 
end
----!!! name:name  ---  :name => name   ---- [name: name]  ---- [{:name, name}]   (shorthand)
        [{:name, name}]  --> name:name    (if last arg in func, omit brackets)   kwl
-----
defmodule HelloWeb.HelloView do
  use HelloWeb, :view
end    
-------
<h1>Hello <%= String.capitalize(@name) %>!</h1>
----
  b: 4000/Slavik      --> Hello Slavik

************************************************************
      ROUTER PIPELINE OF PLUGS (takes conn -> conn -> conn ->)

defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]                 ---services: fetching session, flash (user messages), security 
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end
  scope "/", HelloWeb do
    pipe_through :browser                             --- this appl uses browser pipleline 
    get "/hello/:name", HelloController, :world
    get "/", PageController, :index
  end
end 
*******************************************************************************************************
                      RUMBLE PROJECT 

                  takes video from user 
                  attaches commet to video from user in real time 
                  plays video with all comments (from all users)

connection 
    |> endpoint()                           ---lib/rumble_web/endpoint.ex
    |> router()                             ---lib/rumble_web/router.ex
      |> browser_pipleline()                      part of router, dispatches connection
    |> UserController.index()               ---returns all users 
    |> UserView.render("index.html")

!!! business logic in controller or better in Context layer
        to be able to interact with busines logic from controller, channels, remote APIs
        changing context does not require chaning controller
------------------
mix phx.new rumble 
...configure db in config/dev.ex
mix ecto.create           
mix phx.server  

-------------------------
lib/rumble_web/templates/page/index.html.eex 

    <%= gettext "Welcome to %{name}!", name: "Rumbl.io" %>

-----
  --> Welcome to Rumbl.io 

----------------------------
USER MODEL  (lib/rumble/accounts/user.ex) ----- id, name, username 

    defmodule Rumbl.Accounts.User do              ---- Rumble.Accounts.User struct
      defstruct [:id, :name, :username]
    end
    ---------
    !!! struct (eval atcompilation time) vs map (eval at runtime)
      w/o server running, > iex -S mix         !!! -S mix gives access to all modules 
        iex> alias Rumbl.Accounts.User
            > user = %{un: "Slavik"}      --> %{un: "Slavik"}
            > user.username               -->  (KeyError) key :username not found in: %{un: "Slavik"}
        ------
            >  user1 = %User{un: "Slavik"}  --> compilation error 
            > slavik = %User{name: "Slavik"}   --> 
                      %Rumbl.Accounts.User{id: nil, name: "Slavik", username: nil}
                      !!! undefinded keys ---- default vals 
            > slavik.name     --> "Slavik"
            > slavik.__struct__     --> Rumbl.Accounts.User       !!! the only dif with maps
----------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)
                to get list of users (hard coded)
                to get user by id 
                to get users by one of the keys as params

  defmodule Rumbl.Accounts do
    @moduledoc """
    The Accounts context.
    """

    alias Rumbl.Accounts.User 

    def list_users do
      [
        %User{id: "1", name: "JosÃ©", username: "josevalim"},
        %User{id: "2", name: "Bruce", username: "redrapids"},
        %User{id: "3", name: "Chris", username: "chrismccord"}
      ]
    end

    def get_user(id) do
      Enum.find(list_users(), fn map -> map.id == id end)
    end

    def get_user_by(params) do
      Enum.find(list_users(), fn map ->
        Enum.all?(params, fn {key, val} -> Map.get(map, key) == val end)
      end)
    end
  end
  ----- > iex -S mix 
  > alias Rumbl.Accounts
  > alias Rumbl.Accounts.User
  > Accounts.list_users()
  > Accounts.get_user("1")
  > Accounts.get_user_by(name: "Bruce")

-----------------------------------------------------------------------                          
ROUTER 
   
    get "/users", UserController, :index
    get "/users/:id", UserController, :show

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
        1. INDEX (all users)
      
CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)

    defmodule RumblWeb.UserController do
      use RumblWeb, :controller

      alias Rumbl.Accounts

      def index(conn, _params) do
        users = Accounts.list_users()
        render(conn, "index.html", users: users)
      end
    end

---------------------------------------------------------------------
VIEW (lib/rumbl_web/views/user_view.ex)

    defmodule RumblWeb.UserView do
      use RumblWeb, :view

      alias Rumbl.Accounts

      def first_name(%Accounts.User{name: name}) do
        name
        |> String.split(" ")
        |> Enum.at(0)
      end
    end

-----------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/user/index.html.eex)

    <h1>Listing users</h1>
    <table>
        <%= for user <- @users do %> 
            <tr>
                <td><b><%= first_name(user) %></b>  (<%= user.id %>)</td>
                <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>   	
            </tr>
        <% end %>
    </table>
    -----
    !!! Link --> fun     --> "<a href=\"/show/\">View</a>"  --> <a href="/show/">View</a>
        > iex -S mix 
        >  Phoenix.HTML.Link.link("Home", to: "/")     -->
                {:safe, [60, "a", [[32, "href", 61, 34, "/", 34]], 62, "Home", 60, 47, "a", 62]}

       !!! :safe and I/O list   (ex I/O used to write vals to a socket)
    ----
    > Phoenix.HTML.Link.link("Home", to: "/") |> Phoenix.HTML.safe_to_string()     --> "<a href=\"/\">Home</a>"
        !!! Phoenix.HTML  --- html fun-ty in views (generate links, working with forms...)
                              protect from cross-site scripting (XSS) attacks
----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
                                  SHOW (one user, by id) see above: User model, context, router

CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)

    defmodule RumblWeb.UserController do
      use RumblWeb, :controller

      alias Rumbl.Accounts      

      def show(conn, %{"id" => id}) do
        user = Accounts.get_user(id)
        render(conn, "show.html", user: user)
      end
    end

VIEW  ---- same as before 

TEMPLATE (lib/rumbl_web/templates/user/show.html.eex)

    <h1>Showing User</h1>
    <b><%= first_name(@user) %></b> (<%= @user.id %>)
----------------------------------------------------------------------------------------------------------------
          NESTING TEMPLATES  (index.html.eex and show.html.eex refer to user.html.eex)

(lib/rumbl_web/templates/user/user.html.eex)

    <strong><%= first_name(@user) %></strong>  (<%= user.id %>)

(lib/rumbl_web/templates/user/index.html.eex)

    <h1>Listing users</h1>
    <table>
        <%= for user <- @users do %> 
            <tr>
                <td><%= render "user.html", user: user %></td>
                <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>   	
            </tr>
        <% end %>
    </table>
    

(lib/rumbl_web/templates/user/show.html.eex)

    <h1>Showing User</h1>
    <%= render "user.html", user: @user %>
------
!!! view extracts template (user.html.eex) from file system
         makes this template a function in the view itself
------
> iex -S mix 
> user = Rumble.Accounts.get_user("2")   -->    %Rumble.Accounts.User{id: "2", name: "Bruce", username: "redrapids"}
> view = RumbleWeb.UserView.render("user.html", user: user)   --> 
              {:safe, ["<strong>", "Bruce", "</strong>  (", "2", ")\r\n"]}
> Phoenix.HTML.safe_to_string(view)   -->    "<strong>Bruce</strong>  (2)\r\n"

    !!! fetch user from repository 
        render template directly from view 
            !!! each template is render(template_name, assigns) of the respective view  
                    assigns ---- []  <-- plugs, controller funs 
                can render 
!!! Rumble.UserController  
          show ---- render ---"show.html"
    Rumble.UserView 
    ../templates/user/......     (all templates in this F turned into funs by view inside view) 

--------------------------------------------------------------------------------------------------------
                    LAYOUTS

controller's render --> view --> template 
    Rumble.UserController  ---- render Rumble.LayoutView ---- .../templates/layout/app.html.eex
                                render Rumble.UserView  ----- .../templates/user/....
    .../templates/layout/app.html.eex
              <%= @inner_content %>           ----- embed controller's action's html 

*********************************************************************************************************
                              ECTO REPOSITORY BACKED BY PostgreSQL db 

(ecto/rumble/lib/rumble/repo.ex)    ---- ecto repository, created when proj was created

    defmodule Rumble.Repo do
      use Ecto.Repo,
        otp_app: :rumble,
        adapter: Ecto.Adapters.Postgres
    end

------------------------------------------------
USER MODULE  ----- SCHEMA 

  (lib/rumble/accounts/user.ex)

      defmodule Rumbl.Accounts.User do
        use Ecto.Schema
        import Ecto.Changeset

        schema "users" do
          field :name, :string
          field :username, :string

          timestamps()
        end
      end
  !!! DSL uses Schema and field macros
      primary key :id  ---- automatically
      from schema, ecto defines Elixir struct, as before.... %Accounts.User{}

---------------
MIGRATION 

    > mix ecto.gen.migration create_user
    (rumble/priv/repo/migrations/(timestamp)_create_user.exs)   ---- generated file 

          defmodule Rumble.Repo.Migrations.CreateUser do
            use Ecto.Migration

            def change do

            end
          end

          --------------- (add in change fun):
          def change do
            create table(:users) do
              add :name, :string
              add :username, :string, null: false
              add :password_hash, :string

              timestamps()
            end

            create unique_index(:users, [:username])
          end
          -------
          !!! create, add, timestamps (-> fields: inserted_at, updated_at) macros
              match fields with User schema 
              --> table ---id, name, username (unique), password_hash, inserted_at, updated_at
                          !!! password_hash not in schema, will be added later when authentication
MIGRATE TO DB 
   > mix ecto.migrate         !!! for this envoronment (dev, prod, test)
                                  to switch env: MIX_EVN
----------
!!! OTP manages services: Ecto repositories... supervised in case Phoenix or Ecto crash
    automaticall... Rumble.Repo addid in children arr in supervision tree: 
        (lib/rumble/application.ex)
            ....
            def start(_type, _args) do
              children = [Rumble.Repo, .....]
            end
----------------
INSERT NEW USER INTO DB 
  > eix -S mix 
  > alias Rumble.Repo
  > alias Rumble.Accounts.User
  > Repo.insert(%User{name: "Slavik", username: "slav"})      -->
          {:ok,
            %Rumble.Accounts.User{
              __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
              id: 1,
              inserted_at: ~N[2020-07-04 10:35:39],
              name: "Slavik",
              updated_at: ~N[2020-07-04 10:35:39],
              username: "slav"
            }}
    (create a few)
  > Repo.all(User)    --> [.....]
  > Repo.get(User, 1)     --> 

        %Rumble.Accounts.User{
          __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
          id: 1,
          inserted_at: ~N[2020-07-04 10:35:39],
          name: "Slavik",
          updated_at: ~N[2020-07-04 10:35:39],
          username: "slav"
        }

--------------------------
DB ACCESS TO ACCOUNTS CONTEXT 

    CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)

        defmodule Rumble.Accounts do
          @moduledoc """
          The Accounts context.
          """

          alias Rumble.Repo
          alias Rumble.Accounts.User

          def get_user(id) do
            Repo.get(User, id)
          end

          def get_user!(id) do
            Repo.get!(User, id)                 !!! if no user --> Ecto.NotFoundError
          end

          def get_user_by(params) do
            Repo.get_by(User, params)
          end

          def list_users do
            Repo.all(User)
          end
        end
---------
!!! no change in controller, only in context
> mix phx.server  

**************************************************************************************************
                      NEW  ---- with form, db....

CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)  --- add new fun

    defmodule RumbleWeb.UserController do
      use RumbleWeb, :controller

      alias Rumble.Accounts
      alias Rumbl.Accounts.User

      def new(conn, _params) do
        changeset = Accounts.change_user(%User{})       ---- %Rumble.Accounts.User will have changeset fun 
        render(conn, "new.html", changeset: changeset)
      end
    end
    ---------
    !!! change_user --> Ecto.Changeset --- manage records changes
                                           cast params
                                           validations
----------------------------------
USER MODULE  ----- SCHEMA   ----add changeset fun: 

  (lib/rumble/accounts/user.ex)   ---- add changeset fun 

      defmodule Rumbl.Accounts.User do
        use Ecto.Schema
        import Ecto.Changeset

        schema "users" do
          field :name, :string
          field :username, :string

          timestamps()
        end
        def changeset(user, attrs) do                   !!! user is %Accounts.User{...}
          user
          |> cast(attrs, [:name, :username])            !!! to be cast as inputs to schema types, rest rejected
          |> validate_required([:name, :username])         --> Echto.Changeset 
          |> validate_length(:username, min: 1, max: 20)
        end
      end

----------------------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)    ----add change_user fun 

    defmodule Rumble.Accounts do
      @moduledoc """
      The Accounts context.
      """
      alias Rumbl.Accounts.User
      alias Rumbl.Repo      

      def change_user(%User{} = user) do
        User.changeset(user, %{})
      end
    end
-----------------
!!! controller communicates with public (Accounts, Accounts.User) and private (rest) APIs
    Accounts.change_user is private (via layers)
    update policies (validations, error reporting, ...) decouple from User schema via changeset 

----------------------------------------------------------------------------------------
RESOURCES (CRUD)
ROUTER 

  scope "/", RumbleWeb do
    pipe_through :browser

    get "/", PageController, :index
    resources "/users", UserController, only: [:index, :show, :new, :create]
  end
  ------
  w/o only: [......]   --> 
        get "/users", UserController, :index
        get "/users/:id/edit", UserController, :edit
        get "/users/new", UserController, :new
        get "/users/:id", UserController, :show

        post "/users", UserController, :create

        put "/users/:id", UserController, :update
        patch "/users/:id", UserController, :update

        delete "/users/:id", UserController, :delete
  
  ------
  > mix phx.routes     --> shows all routes 
  ------------------------------------------------------------
  TEMPLATE (lib/rumbl_web/templates/user/new.html.eex)

      <h1>New User</h1>
      <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
        <%= text_input f, :name, placeholder: "Name" %>
        <%= text_input f, :username, placeholder: "Username" %>
        <%= submit "Create User" %> 
      <% end %>

    -----
    !!! form_for   --> security, UTF-8 encoding, ...
        form_for(changeset, path, anon-fun)
        fn f ->        ---- f is form-data 
------
!!! see Phoenix.HTML 
> mix phx.server    -->  /4000/users/new     --> displays form    --- see devtools ---html

      <input id="user_name" name="user[name]" ....>     ---- pulled from changeset 
      ...
      !!! Ecto passes changeset to form_for fun 
          could pass hard-coded Echto.Changeset to form, but when form tightly coupled with changeset --> 
                cannot change data abstraction if needed 
          Phoenix.HTML.FormData protocol used; separates interface from implementation
                                implemented by Ecto.Changeset --> (intermal data to structure digestible by form)
          form send data to post "/users"
---------------------------------------------------------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)   ---- get data from form 

    defmodule Rumbl.Accounts do
      @moduledoc """
      The Accounts context.
      """

      alias Rumbl.Accounts.User

      alias Rumbl.Repo      

      def create_user(attrs \\ %{}) do
        %User{}
        |> User.changeset(attrs)
        |> Repo.insert()
      end
    end