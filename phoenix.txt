> mix phx.new proj    
proj> mix setup 

(config/dev.exs) ---- password for postgres  (default database, name is "postgres", "postgres")
proj> mix ecto.create        !!! creates db 
> mix phx.server     (runs on 4000)
!!! > iex -S mix phx.server     (can also debug, rugn iex commands, query db....)

!!! mix phx.new live_view_counter --live --no-ecto  


********************************************************************************************************
def mount(_params, _session, socket) do
  {:ok, assign(socket, :val, 0) }
end

def handle_event("inc", _, socket) do
  {:noreply, update(socket, :val, &(&1 + 1))}
end

def render(assigns) do
    ~L"""
    <div>
      <h1>The count is: <%= @val %></h1>
      <button phx-click="dec">-</button>
      <button phx-click="inc">+</button>
    </div>
    """
  end

!!! :noreply -----  no messages to caller of fun 
!!!  ~L sigil is a macro included when the use Phoenix.LiveView is invoked at the top of the file
_______________________________________________________________________________________________
                            ADD WEBSOCKET (BUILT-IN)

@topic "live"       ------ like global var, channel, acceccible anywhere

def mount(_session, _params, socket) do
    LiveViewCounterWeb.Endpoint.subscribe(@topic)         # subscribe to the channel
    {:ok, assign(socket, :val, 0)}
end

def handle_event("inc", _msg, socket) do
  new_state = update(socket, :val, &(&1 + 1))
  LiveViewCounterWeb.Endpoint.broadcast_from(self(), @topic, "inc", new_state.assigns)
  {:noreply, new_state}
end

!!! self()  ----- current process  (message sent from self() via @topic channel)
    %{"inc" => new_state.assigns}
!!! new_state is an instance of the Phoenix.LiveView.Socket socket
!!! new_state.assigns  --> %{ ....... , val: 1 }    ----- after button clicked val: 1
###############################

#Phoenix.LiveView.Socket<
  assigns: %{
    flash: %{},
    live_view_action: nil,
    live_view_module: LiveViewCounterWeb.Counter,
    val: 1
  },
  changed: %{val: true},
  endpoint: LiveViewCounterWeb.Endpoint,
  id: "phx-Ffq41_T8jTC_3gED",
  parent_pid: nil,
  view: LiveViewCounterWeb.Counter,
  ...
}
##############################

def handle_info(msg, socket) do
  {:noreply, assign(socket, msg.payload)}
end

!!! msg  ----- received message
!!! socket ------  Phoenix.Socke
!!! without  :noreply  --> recursive loop of updates


************************************************************************************************************
************************************************************************************************************
                          PROGRAMMING PHOENIX (BOOK)

DATA FLOW 

  connection |> phoenis 
                  (layers):
                      |> endpoint()     ---- consists of plugs for each req... last plug is router 
                      |> router()
                      |> pipelines()
                      |> controller() 
                            has: |> common_services()   ---- implemented with plug 
                                 |> action()

  connection as req -> conn -> conn -> conn -> as res to front  (plugs)
  .ex --compiled to .beam files (run on Erlang virtual machine)
  .eex  -- Elixir scripts (not to .beam files)

config/config.exs     ----applic wide (logging, endpoints)
      /dev.exs
      /prod.exs
      /test.exs           !!! dev, prod, test --- switch via MIX_ENV
      /prod.secret.exs

config/config.exs   ---- config: hello, HelloWeb.Endpoint
lib/hello_web/endpoint.ex --- plugs for applic (for every req)

M (accesses data) --- V (present data) --- C (coordination between M, C)

***********************************************************************************************************
                              HELLP WORLD APP 
                    load url 
                    print string 

> mix phx.new hello

config/dev.ex  ----username: "postgres" ....  password: "gerK..55" .... database: "postgres" ... 
hello > mix ecto.create  
> mix phx.server  
----
1. ROUTER (router.ex)
   get "/hello", HelloController, :world 

2. CONTROLLER (controllers/hello_controller.ex)

    defmodule HelloWeb.HelloController do
      use HelloWeb, :controller

      def world(conn, _params) do
        render(conn, "world.html")
      end
    end

3. VIEW (views/hello_view.ex)  ---- helps to render template 

    defmodule HelloWeb.HelloView do
      use HelloWeb, :view
    end

4. TEMPLATE (templates/hello/world.html.eex)    !!! .eex 

      <h1>Hello World!</h1>
  -----
  --> live reloading (see 4000 port)

---------------------------------------------------------------------------------
          + PARAMS 

get "/hello/:name", HelloController, :world
----
def world(conn, %{"name" => name}) do
  render(conn, "world.html", name:name)     ----    render(conn, "world.html", [name:name]) 
end
----!!! name:name  ---  :name => name   ---- [name: name]  ---- [{:name, name}]   (shorthand)
        [{:name, name}]  --> name:name    (if last arg in func, omit brackets)   kwl
-----
defmodule HelloWeb.HelloView do
  use HelloWeb, :view
end    
-------
<h1>Hello <%= String.capitalize(@name) %>!</h1>
----
  b: 4000/Slavik      --> Hello Slavik

************************************************************
      ROUTER PIPELINE OF PLUGS (takes conn -> conn -> conn ->)

defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]                 ---services: fetching session, flash (user messages), security 
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end
  scope "/", HelloWeb do
    pipe_through :browser                             --- this appl uses browser pipleline 
    get "/hello/:name", HelloController, :world
    get "/", PageController, :index
  end
end 
*******************************************************************************************************
                      RUMBLE PROJECT 

                  takes video from user 
                  attaches commet to video from user in real time 
                  plays video with all comments (from all users)

connection 
    |> endpoint()                           ---lib/rumble_web/endpoint.ex
    |> router()                             ---lib/rumble_web/router.ex
      |> browser_pipleline()                      part of router, dispatches connection
    |> UserController.index()               ---returns all users 
    |> UserView.render("index.html")

!!! business logic in controller or better in Context layer
        to be able to interact with busines logic from controller, channels, remote APIs
        changing context does not require chaning controller
------------------
mix phx.new rumble 
...configure db in config/dev.ex
mix ecto.create           
mix phx.server  

-------------------------
lib/rumble_web/templates/page/index.html.eex 

    <%= gettext "Welcome to %{name}!", name: "Rumbl.io" %>

-----
  --> Welcome to Rumbl.io 

----------------------------
USER MODEL  (lib/rumble/accounts/user.ex) ----- id, name, username 

    defmodule Rumbl.Accounts.User do              ---- Rumble.Accounts.User struct
      defstruct [:id, :name, :username]
    end
    ---------
    !!! struct (eval atcompilation time) vs map (eval at runtime)
      w/o server running, > iex -S mix         !!! -S mix gives access to all modules 
        iex> alias Rumbl.Accounts.User
            > user = %{un: "Slavik"}      --> %{un: "Slavik"}
            > user.username               -->  (KeyError) key :username not found in: %{un: "Slavik"}
        ------
            >  user1 = %User{un: "Slavik"}  --> compilation error 
            > slavik = %User{name: "Slavik"}   --> 
                      %Rumbl.Accounts.User{id: nil, name: "Slavik", username: nil}
                      !!! undefinded keys ---- default vals 
            > slavik.name     --> "Slavik"
            > slavik.__struct__     --> Rumbl.Accounts.User       !!! the only dif with maps
----------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)
                to get list of users (hard coded)
                to get user by id 
                to get users by one of the keys as params

  defmodule Rumbl.Accounts do
    @moduledoc """
    The Accounts context.
    """

    alias Rumbl.Accounts.User 

    def list_users do
      [
        %User{id: "1", name: "JosÃ©", username: "josevalim"},
        %User{id: "2", name: "Bruce", username: "redrapids"},
        %User{id: "3", name: "Chris", username: "chrismccord"}
      ]
    end

    def get_user(id) do
      Enum.find(list_users(), fn map -> map.id == id end)
    end

    def get_user_by(params) do
      Enum.find(list_users(), fn map ->
        Enum.all?(params, fn {key, val} -> Map.get(map, key) == val end)
      end)
    end
  end
  ----- > iex -S mix 
  > alias Rumbl.Accounts
  > alias Rumbl.Accounts.User
  > Accounts.list_users()
  > Accounts.get_user("1")
  > Accounts.get_user_by(name: "Bruce")

-----------------------------------------------------------------------
ROUTER 
   
    get "/users", UserController, :index
    get "/users/:id", UserController, :show

-----------------------------------------------------------------------
CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)

    defmodule RumblWeb.UserController do
      use RumblWeb, :controller

      alias Rumbl.Accounts

      def index(conn, _params) do
        users = Accounts.list_users()
        render(conn, "index.html", users: users)
      end
    end

---------------------------------------------------------------------
VIEW (lib/rumbl_web/views/user_view.ex)

    defmodule RumblWeb.UserView do
      use RumblWeb, :view

      alias Rumbl.Accounts

      def first_name(%Accounts.User{name: name}) do
        name
        |> String.split(" ")
        |> Enum.at(0)
      end
    end

-----------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/user/index.html.eex)

    <h1>Listing users</h1>
    <table>
        <%= for user <- @users do %> 
            <tr>
                <td><b><%= first_name(user) %></b>  (<%= user.id %>)</td>
                <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>   	
            </tr>
        <% end %>
    </table>
    -----
    !!! Link --> fun     --> "<a href=\"/show/\">View</a>"  --> <a href="/show/">View</a>
        > iex -S mix 
        >  Phoenix.HTML.Link.link("Home", to: "/")     -->
                {:safe, [60, "a", [[32, "href", 61, 34, "/", 34]], 62, "Home", 60, 47, "a", 62]}

       !!! :save and I/O list   (ex I/O used to write vals to a socket)
    ----
    > Phoenix.HTML.Link.link("Home", to: "/") |> Phoenix.HTML.safe_to_string()     --> "<a href=\"/\">Home</a>"
        !!! Phoenix.HTML  --- html fun-ty in views (generate links, working with forms...)
                              protect from cross-site scripting (XSS) attacks
----------------------------------------------------------------------


   

