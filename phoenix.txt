> mix phx.new proj    
proj> mix setup 

(config/dev.exs) ---- password for postgres  (default database, name is "postgres", "postgres")
proj> mix ecto.create        !!! creates db 
> mix phx.server     (runs on 4000)
!!! > iex -S mix phx.server     (can also debug, rugn iex commands, query db....)

!!! mix phx.new live_view_counter --live --no-ecto  


********************************************************************************************************
def mount(_params, _session, socket) do
  {:ok, assign(socket, :val, 0) }
end

def handle_event("inc", _, socket) do
  {:noreply, update(socket, :val, &(&1 + 1))}
end

def render(assigns) do
    ~L"""
    <div>
      <h1>The count is: <%= @val %></h1>
      <button phx-click="dec">-</button>
      <button phx-click="inc">+</button>
    </div>
    """
  end

!!! :noreply -----  no messages to caller of fun 
!!!  ~L sigil is a macro included when the use Phoenix.LiveView is invoked at the top of the file
_______________________________________________________________________________________________
                            ADD WEBSOCKET (BUILT-IN)

@topic "live"       ------ like global var, channel, acceccible anywhere

def mount(_session, _params, socket) do
    LiveViewCounterWeb.Endpoint.subscribe(@topic)         # subscribe to the channel
    {:ok, assign(socket, :val, 0)}
end

def handle_event("inc", _msg, socket) do
  new_state = update(socket, :val, &(&1 + 1))
  LiveViewCounterWeb.Endpoint.broadcast_from(self(), @topic, "inc", new_state.assigns)
  {:noreply, new_state}
end

!!! self()  ----- current process  (message sent from self() via @topic channel)
    %{"inc" => new_state.assigns}
!!! new_state is an instance of the Phoenix.LiveView.Socket socket
!!! new_state.assigns  --> %{ ....... , val: 1 }    ----- after button clicked val: 1
###############################

#Phoenix.LiveView.Socket<
  assigns: %{
    flash: %{},
    live_view_action: nil,
    live_view_module: LiveViewCounterWeb.Counter,
    val: 1
  },
  changed: %{val: true},
  endpoint: LiveViewCounterWeb.Endpoint,
  id: "phx-Ffq41_T8jTC_3gED",
  parent_pid: nil,
  view: LiveViewCounterWeb.Counter,
  ...
}
##############################

def handle_info(msg, socket) do
  {:noreply, assign(socket, msg.payload)}
end

!!! msg  ----- received message
!!! socket ------  Phoenix.Socke
!!! without  :noreply  --> recursive loop of updates


************************************************************************************************************
************************************************************************************************************
                          PROGRAMMING PHOENIX (BOOK)

DATA FLOW 

  connection |> phoenix 
                  (layers):
                      |> endpoint()     ---- consists of plugs for each req... last plug is router 
                      |> router()
                      |> pipelines()
                      |> controller() 
                            has: |> common_services()   ---- implemented with plug 
                                 |> action()

  connection as req -> conn -> conn -> conn -> as res to front  (plugs)
  .ex --compiled to .beam files (run on Erlang virtual machine)
  .eex  -- Elixir scripts (not to .beam files)

config/config.exs     ----applic wide (logging, endpoints)
      /dev.exs
      /prod.exs
      /test.exs           !!! dev, prod, test --- switch via MIX_ENV
      /prod.secret.exs

config/config.exs   ---- config: hello, HelloWeb.Endpoint
lib/hello_web/endpoint.ex --- plugs for applic (for every req)

M (accesses data) --- V (present data) --- C (coordination between M, C)

***********************************************************************************************************
                              HELLP WORLD APP 
                    load url 
                    print string 

> mix phx.new hello

config/dev.ex  ----username: "postgres" ....  password: "gerK..55" .... database: "postgres" ... 
hello > mix ecto.create  
> mix phx.server  
----
1. ROUTER (router.ex)
   get "/hello", HelloController, :world 

2. CONTROLLER (controllers/hello_controller.ex)

    defmodule HelloWeb.HelloController do
      use HelloWeb, :controller

      def world(conn, _params) do
        render(conn, "world.html")
      end
    end

3. VIEW (views/hello_view.ex)  ---- helps to render template 

    defmodule HelloWeb.HelloView do
      use HelloWeb, :view
    end

4. TEMPLATE (templates/hello/world.html.eex)    !!! .eex 

      <h1>Hello World!</h1>
  -----
  --> live reloading (see 4000 port)

---------------------------------------------------------------------------------
          + PARAMS 

get "/hello/:name", HelloController, :world
----
def world(conn, %{"name" => name}) do
  render(conn, "world.html", name:name)     ----    render(conn, "world.html", [name:name]) 
end
----!!! name:name  ---  :name => name   ---- [name: name]  ---- [{:name, name}]   (shorthand)
        [{:name, name}]  --> name:name    (if last arg in func, omit brackets)   kwl
-----
defmodule HelloWeb.HelloView do
  use HelloWeb, :view
end    
-------
<h1>Hello <%= String.capitalize(@name) %>!</h1>
----
  b: 4000/Slavik      --> Hello Slavik

************************************************************
      ROUTER PIPELINE OF PLUGS (takes conn -> conn -> conn ->)

defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]                 ---services: fetching session, flash (user messages), security 
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end
  scope "/", HelloWeb do
    pipe_through :browser                             --- this appl uses browser pipleline 
    get "/hello/:name", HelloController, :world
    get "/", PageController, :index
  end
end 
*******************************************************************************************************
*******************************************************************************************************

                      RUMBLE PROJECT 

                  takes video from user 
                  attaches commet to video from user in real time 
                  plays video with all comments (from all users)

connection 
    |> endpoint()                           ---lib/rumble_web/endpoint.ex
    |> router()                             ---lib/rumble_web/router.ex
      |> browser_pipleline()                      part of router, dispatches connection
    |> UserController.index()               ---returns all users 
    |> UserView.render("index.html")

!!! business logic in controller or better in Context layer
        to be able to interact with busines logic from controller, channels, remote APIs
        changing context does not require chaning controller
------------------
mix phx.new rumble 
...configure db in config/dev.ex
mix ecto.create           
mix phx.server  

-------------------------
lib/rumble_web/templates/page/index.html.eex 

    <%= gettext "Welcome to %{name}!", name: "Rumbl.io" %>

-----
  --> Welcome to Rumbl.io 

----------------------------
USER MODEL  (lib/rumble/accounts/user.ex) ----- id, name, username 

    defmodule Rumbl.Accounts.User do              ---- Rumble.Accounts.User struct
      defstruct [:id, :name, :username]
    end
    ---------
    !!! struct (eval atcompilation time) vs map (eval at runtime)
      w/o server running, > iex -S mix         !!! -S mix gives access to all modules 
        iex> alias Rumbl.Accounts.User
            > user = %{un: "Slavik"}      --> %{un: "Slavik"}
            > user.username               -->  (KeyError) key :username not found in: %{un: "Slavik"}
        ------
            > user1 = %User{un: "Slavik"}  --> compilation error 
            > slavik = %User{name: "Slavik"}   --> 
                      %Rumbl.Accounts.User{id: nil, name: "Slavik", username: nil}
                      !!! undefinded keys ---- default vals 
            > slavik.name     --> "Slavik"
            > slavik.__struct__     --> Rumbl.Accounts.User       !!! the only dif with maps
----------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)
                to get list of users (hard coded)
                to get user by id 
                to get users by one of the keys as params

  defmodule Rumbl.Accounts do
    @moduledoc """
    The Accounts context.
    """

    alias Rumbl.Accounts.User 

    def list_users do
      [
        %User{id: "1", name: "JosÃ©", username: "josevalim"},
        %User{id: "2", name: "Bruce", username: "redrapids"},
        %User{id: "3", name: "Chris", username: "chrismccord"}
      ]
    end

    def get_user(id) do
      Enum.find(list_users(), fn map -> map.id == id end)
    end

    def get_user_by(params) do
      Enum.find(list_users(), fn map ->
        Enum.all?(params, fn {key, val} -> Map.get(map, key) == val end)
      end)
    end
  end
  ----- > iex -S mix 
  > alias Rumbl.Accounts
  > alias Rumbl.Accounts.User
  > Accounts.list_users()
  > Accounts.get_user("1")
  > Accounts.get_user_by(name: "Bruce")

-----------------------------------------------------------------------                          
ROUTER 
   
    get "/users", UserController, :index
    get "/users/:id", UserController, :show

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
        1. INDEX (all users)
      
CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)

    defmodule RumblWeb.UserController do
      use RumblWeb, :controller

      alias Rumbl.Accounts

      def index(conn, _params) do
        users = Accounts.list_users()
        render(conn, "index.html", users: users)
      end
    end

---------------------------------------------------------------------
VIEW (lib/rumbl_web/views/user_view.ex)

    defmodule RumblWeb.UserView do
      use RumblWeb, :view

      alias Rumbl.Accounts

      def first_name(%Accounts.User{name: name}) do
        name
        |> String.split(" ")
        |> Enum.at(0)
      end
    end

-----------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/user/index.html.eex)

    <h1>Listing users</h1>
    <table>
        <%= for user <- @users do %> 
            <tr>
                <td><b><%= first_name(user) %></b>  (<%= user.id %>)</td>
                <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>   	
            </tr>
        <% end %>
    </table>
    -----
    !!! Link --> fun     --> "<a href=\"/show/\">View</a>"  --> <a href="/show/">View</a>
        > iex -S mix 
        >  Phoenix.HTML.Link.link("Home", to: "/")     -->
                {:safe, [60, "a", [[32, "href", 61, 34, "/", 34]], 62, "Home", 60, 47, "a", 62]}

       !!! :safe and I/O list   (ex I/O used to write vals to a socket)
    ----
    > Phoenix.HTML.Link.link("Home", to: "/") |> Phoenix.HTML.safe_to_string()     --> "<a href=\"/\">Home</a>"
        !!! Phoenix.HTML  --- html fun-ty in views (generate links, working with forms...)
                              protect from cross-site scripting (XSS) attacks
----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
                                  SHOW (one user, by id) see above: User model, context, router

CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)

    defmodule RumblWeb.UserController do
      use RumblWeb, :controller

      alias Rumbl.Accounts      

      def show(conn, %{"id" => id}) do
        user = Accounts.get_user(id)
        render(conn, "show.html", user: user)
      end
    end

VIEW  ---- same as before 

TEMPLATE (lib/rumbl_web/templates/user/show.html.eex)

    <h1>Showing User</h1>
    <b><%= first_name(@user) %></b> (<%= @user.id %>)
----------------------------------------------------------------------------------------------------------------
          NESTING TEMPLATES  (index.html.eex and show.html.eex refer to user.html.eex)

(lib/rumbl_web/templates/user/user.html.eex)

    <strong><%= first_name(@user) %></strong>  (<%= user.id %>)

(lib/rumbl_web/templates/user/index.html.eex)

    <h1>Listing users</h1>
    <table>
        <%= for user <- @users do %> 
            <tr>
                <td><%= render "user.html", user: user %></td>
                <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>   	
            </tr>
        <% end %>
    </table>
    

(lib/rumbl_web/templates/user/show.html.eex)

    <h1>Showing User</h1>
    <%= render "user.html", user: @user %>
------
!!! view extracts template (user.html.eex) from file system
         makes this template a function in the view itself
------
> iex -S mix 
> user = Rumble.Accounts.get_user("2")   -->    %Rumble.Accounts.User{id: "2", name: "Bruce", username: "redrapids"}
> view = RumbleWeb.UserView.render("user.html", user: user)   --> 
              {:safe, ["<strong>", "Bruce", "</strong>  (", "2", ")\r\n"]}
> Phoenix.HTML.safe_to_string(view)   -->    "<strong>Bruce</strong>  (2)\r\n"

    !!! fetch user from repository 
        render template directly from view 
            !!! each template is render(template_name, assigns) of the respective view  
                    assigns ---- []  <-- plugs, controller funs 
                can render 
!!! Rumble.UserController  
          show ---- render ---"show.html"
    Rumble.UserView 
    ../templates/user/......     (all templates in this F turned into funs by view inside view) 

--------------------------------------------------------------------------------------------------------
                    LAYOUTS

controller's render --> view --> template 
    Rumble.UserController  ---- render Rumble.LayoutView ---- .../templates/layout/app.html.eex
                                render Rumble.UserView  ----- .../templates/user/....
    .../templates/layout/app.html.eex
              <%= @inner_content %>           ----- embed controller's action's html 

*********************************************************************************************************
                              ECTO REPOSITORY BACKED BY PostgreSQL db 

(ecto/rumble/lib/rumble/repo.ex)    ---- ecto repository, created when proj was created

    defmodule Rumble.Repo do
      use Ecto.Repo,
        otp_app: :rumble,
        adapter: Ecto.Adapters.Postgres
    end

------------------------------------------------
USER MODULE  ----- SCHEMA 

  (lib/rumble/accounts/user.ex)

      defmodule Rumbl.Accounts.User do
        use Ecto.Schema
        import Ecto.Changeset

        schema "users" do
          field :name, :string
          field :username, :string

          timestamps()
        end
      end
  !!! DSL uses Schema and field macros
      primary key :id  ---- automatically
      from schema, ecto defines Elixir struct, as before.... %Accounts.User{}

---------------
MIGRATION 

    > mix ecto.gen.migration create_user
    (rumble/priv/repo/migrations/(timestamp)_create_user.exs)   ---- generated file 

          defmodule Rumble.Repo.Migrations.CreateUser do
            use Ecto.Migration

            def change do

            end
          end

          --------------- (add in change fun):
          def change do
            create table(:users) do
              add :name, :string
              add :username, :string, null: false
              add :password_hash, :string

              timestamps()
            end

            create unique_index(:users, [:username])
          end
          -------
          !!! create, add, timestamps (-> fields: inserted_at, updated_at) macros
              match fields with User schema 
              --> table ---id, name, username (unique), password_hash, inserted_at, updated_at
                          !!! password_hash not in schema, will be added later when authentication
MIGRATE TO DB 
   > mix ecto.migrate         !!! for this envoronment (dev, prod, test)
                                  to switch env: MIX_EVN
----------
!!! OTP manages services: Ecto repositories... supervised in case Phoenix or Ecto crash
    automaticall... Rumble.Repo addid in children arr in supervision tree: 
        (lib/rumble/application.ex)
            ....
            def start(_type, _args) do
              children = [Rumble.Repo, .....]
            end
----------------
INSERT NEW USER INTO DB 
  > eix -S mix 
  > alias Rumble.Repo
  > alias Rumble.Accounts.User
  > Repo.insert(%User{name: "Slavik", username: "slav"})      -->
          {:ok,
            %Rumble.Accounts.User{
              __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
              id: 1,
              inserted_at: ~N[2020-07-04 10:35:39],
              name: "Slavik",
              updated_at: ~N[2020-07-04 10:35:39],
              username: "slav"
            }}
    (create a few)
  > Repo.all(User)    --> [.....]
  > Repo.get(User, 1)     --> 

        %Rumble.Accounts.User{
          __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
          id: 1,
          inserted_at: ~N[2020-07-04 10:35:39],
          name: "Slavik",
          updated_at: ~N[2020-07-04 10:35:39],
          username: "slav"
        }

--------------------------
DB ACCESS TO ACCOUNTS CONTEXT 

    CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)

        defmodule Rumble.Accounts do
          @moduledoc """
          The Accounts context.
          """

          alias Rumble.Repo
          alias Rumble.Accounts.User

          def get_user(id) do
            Repo.get(User, id)
          end

          def get_user!(id) do
            Repo.get!(User, id)                 !!! if no user --> Ecto.NotFoundError
          end

          def get_user_by(params) do
            Repo.get_by(User, params)
          end

          def list_users do
            Repo.all(User)
          end
        end
---------
!!! no change in controller, only in context
> mix phx.server  

**************************************************************************************************
                      NEW  ---- with form, db....

CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)  --- add new fun

    defmodule RumbleWeb.UserController do
      use RumbleWeb, :controller

      alias Rumble.Accounts
      alias Rumbl.Accounts.User

      def new(conn, _params) do
        changeset = Accounts.change_user(%User{})       ---- %Rumble.Accounts.User will have changeset fun 
        render(conn, "new.html", changeset: changeset)
      end
    end
    ---------
    !!! change_user --> Ecto.Changeset --- manage records changes
                                           cast params
                                           validations
----------------------------------
USER MODULE  ----- SCHEMA   ----add changeset fun: 

  (lib/rumble/accounts/user.ex)   ---- add changeset fun 

      defmodule Rumbl.Accounts.User do
        use Ecto.Schema
        import Ecto.Changeset

        schema "users" do
          field :name, :string
          field :username, :string

          timestamps()
        end
        def changeset(user, attrs) do                   !!! user is %Accounts.User{...}
          user
          |> cast(attrs, [:name, :username])            !!! to be cast as inputs to schema types, rest rejected
          |> validate_required([:name, :username])         --> Echto.Changeset 
          |> validate_length(:username, min: 1, max: 20)
        end
      end

----------------------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)    ----add change_user fun 

    defmodule Rumble.Accounts do
      @moduledoc """
      The Accounts context.
      """
      alias Rumbl.Accounts.User
      alias Rumbl.Repo      

      def change_user(%User{} = user) do
        User.changeset(user, %{})
      end
    end
-----------------
!!! controller communicates with public (Accounts, Accounts.User) and private (rest) APIs
    Accounts.change_user is private (via layers)
    update policies (validations, error reporting, ...) decouple from User schema via changeset 

----------------------------------------------------------------------------------------
RESOURCES (CRUD)
ROUTER 

  scope "/", RumbleWeb do
    pipe_through :browser

    get "/", PageController, :index
    resources "/users", UserController, only: [:index, :show, :new, :create]
  end
  ------
  w/o only: [......]   --> 
        get "/users", UserController, :index
        get "/users/:id/edit", UserController, :edit
        get "/users/new", UserController, :new
        get "/users/:id", UserController, :show

        post "/users", UserController, :create

        put "/users/:id", UserController, :update
        patch "/users/:id", UserController, :update

        delete "/users/:id", UserController, :delete
  
  ------
  > mix phx.routes     --> shows all routes 
  ------------------------------------------------------------
  TEMPLATE (lib/rumbl_web/templates/user/new.html.eex)

      <h1>New User</h1>
      <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
        <%= text_input f, :name, placeholder: "Name" %>
        <%= text_input f, :username, placeholder: "Username" %>
        <%= submit "Create User" %> 
      <% end %>

    -----
    !!! form_for   --> security, UTF-8 encoding, ...
        form_for(changeset, path, anon-fun)
        fn f ->        ---- f is form-data 
------
!!! see Phoenix.HTML 
> mix phx.server    -->  /4000/users/new     --> displays form    --- see devtools ---html

      <input id="user_name" name="user[name]" ....>     ---- pulled from changeset 
      ...
      !!! Ecto passes changeset to form_for fun 
          could pass hard-coded Echto.Changeset to form, but when form tightly coupled with changeset --> 
                cannot change data abstraction if needed 
          Phoenix.HTML.FormData protocol used; separates interface from implementation
                                implemented by Ecto.Changeset --> (intermal data to structure digestible by form)
          form send data to post "/users"
---------------------------------------------------------------------------
CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)   ---- get data from form 

    defmodule Rumbl.Accounts do
      @moduledoc """
      The Accounts context.
      """

      alias Rumbl.Accounts.User

      alias Rumbl.Repo      

      def create_user(attrs \\ %{}) do
        %User{}
        |> User.changeset(attrs)
        |> Repo.insert()
      end
    end

---------------------------------------------------------------------------
CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)  --- add create fun

    def create(conn, %{"user" => user_params}) do
      {:ok, user} = Accounts.create_user(user_params)

      conn
      |> put_flash(:info, "#{user.name} created!")
      |> redirect(to: Routes.user_path(conn, :index))
    end
-----
!!! access to routes in appl: RumbleWeb.Router.Helpers
    (/lib/rumble_web.ex) 
    ...
    alias RumbleWeb.Router.Helpers, as: Routes   
            --> allows to use Routes.user_path(...)

------
> mix phx.server   -->   /users/new 

--------------------------------------------------------------------------
ERROR MESSAGE ... ex username too long --> 

    instead of --- {:ok, user}
    error -------- {:error, %Ecto.Changeset{}}

CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)  ---- change to react to invalid changeset 

      def create(conn, %{"user" => user_params}) do
        case Accounts.create_user(user_params) do
          {:ok, user} ->
            conn
            |> put_flash(:info, "#{user.name} created!")
            |> redirect(to: Routes.user_path(conn, :index))

          {:error, %Ecto.Changeset{} = changeset} ->
            render(conn, "new.html", changeset: changeset)        ----!!! changeset - failed validations
        end
      end
---------------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/user/new.html.eex) --- show specific errors for each input field 

    <h1>New User</h1>
    <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
        <%= if @changeset.action do %>
            <div class="alert alert-danger">
                <p>Oops, something went wrong! Please check the errors below.</p>
            </div>
        <% end %>
        <div>
            <%= text_input f, :name, placeholder: "Name" %>
            <%= error_tag f, :name %>
        </div>
        <div>
            <%= text_input f, :username, placeholder: "Username" %>
            <%= error_tag f, :username %>
        </div>
        <%= submit "Create User" %> 
    <% end %>
------
@changeset.action   ---- action is :insert here (for new changeset :action is nil)
changeset track db changes and stores validation errors 
error_tag fun defined in (lib/rumble_web/views/error_helpers.ex)
      def error_tag(form, field) do
        Enum.map(Keyword.get_values(form.errors, field), fn error ->
          content_tag(:span, translate_error(error),
            class: "invalid-feedback",
            phx_feedback_for: input_id(form, field)
          )
        end)
      end
*******************************************************************************************************
                AUTHENTICATION 
                CREATE USERS ---- DB LAYER 

DEPS: using Comeonin (for pw hashing) ---- Pbkdf2 technique of hashing 

  (mix.exs)

    defp deps do
      [
        .........................,
        {:pbkdf2_elixir, "~> 1.0"}
      ]
    end
  >> mix deps.get 

----------------------------------------------------
USER MODULE  ------ add changesets for registration
(lib/rumble/accounts/user.ex)


    defmodule Rumbl.Accounts.User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name, :string
        field :username, :string
        
        field :password, :string, virtual: true
        field :password_hash, :string

        timestamps()
      end

      def registration_changeset(user, params) do
        user
        |> changeset(params)
        |> cast(params, [:password])
        |> validate_required([:password])
        |> validate_length(:password, min: 6, max: 100)
        |> put_pass_hash()
      end

      defp put_pass_hash(changeset) do
        case changeset do
          %Ecto.Changeset{valid?: true, changes: %{password: pass}} ->
            put_change(changeset, :password_hash, Pbkdf2.hash_pwd_salt(pass))

          _ ->
            changeset
        end
      end

      def changeset(user, attrs) do
        user
        |> cast(attrs, [:name, :username])
        |> validate_required([:name, :username])
        |> validate_length(:username, min: 1, max: 20)
      end
    end

------------
>> iex -S mix 
>  alias Rumble.Accounts.Use
> alias Rumble.Router.Helpers, as: Routes
> changeset = User.registration_changeset(%User{}, %{username: "max", name: "Max", password: "lalala"})
        --> 
          #Ecto.Changeset<
            action: nil,
            changes: %{
              name: "Max",
              password: "lalala",
              password_hash: "$pbkdf2-sha512$160000$p43KoMgO6mcwaxWswXuq2Q$HjqnvMLcwalY9eYLXhwGHTia/7HDYUz1O2lMOU.sX9vMDiPO8OCZAy8O1ZW/igsYNSShSzpF.bE.B30.WiDrAA",
              username: "max"
            },
            errors: [],
            data: #Rumble.Accounts.User<>,
            valid?: true
          >

----------------- (earlier created users w/o password)
add tepmpass to all users for now

    > alias Rumble.Repo

    > for u <- Repo.all(User) do
    ...> Repo.update!(User.registration_changeset(u, %{password: "temppass"}))
    ...> end

--------------------------------------------------------------------------------------------------------
                    CREATING USERS ---WEB LAYER 

CONTEXT --- ACCOUNTS  (lib/rumble/accounts.ex)   ---- add register_user fun 

    defmodule Rumbl.Accounts do
      @moduledoc """
      The Accounts context.
      """

      alias Rumbl.Accounts.User
      alias Rumbl.Repo

      .......

      def change_user(%User{} = user) do
        User.changeset(user, %{})
      end
      
      def create_user(attrs \\ %{}) do
        %User{}
        |> User.changeset(attrs)
        |> Repo.insert()
      end

      def change_registration(%User{} = user, params) do
        User.registration_changeset(user, params)
      end

      def register_user(attrs \\ %{}) do
        %User{}
        |> User.registration_changeset(attrs)
        |> Repo.insert()
      end
    end
    ------
    !!! could put all in create_user fun, but better to separate 
        create_user ---- for seeding, sending user invitations, ...
        register_user  ----- with password hashing 

------------------------------------------------------------------------------
CONTROLLER (lib/rumbl_web/controllers/user_controller.ex)   ----- change create action 

    def create(conn, %{"user" => user_params}) do
      case Accounts.register_user(user_params) do      ----- was:  case Accounts.create_user(user_params) do
        {:ok, user} ->
          conn
          |> put_flash(:info, "#{user.name} created!")
          |> redirect(to: Routes.user_path(conn, :index))

        {:error, %Ecto.Changeset{} = changeset} ->
          render(conn, "new.html", changeset: changeset)
      end
    end

--------------------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/user/new.html.eex) --- add password field to form:  

    <h1>New User</h1>
    <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
        <%= if @changeset.action do %>
            <div class="alert alert-danger">
                <p>Oops, something went wrong! Please check the errors below.</p>
            </div>
        <% end %>
        <div>
            <%= text_input f, :name, placeholder: "Name" %>
            <%= error_tag f, :name %>
        </div>
        <div>
            <%= text_input f, :username, placeholder: "Username" %>
            <%= error_tag f, :username %>
        </div>
        <div>
            <%= password_input f, :password, placeholder: "Password" %> <%= error_tag f, :password %>
            <%= error_tag f, :password %>
        </div>
        <%= submit "Create User" %> 
    <% end %>

-------
> mix phx.server    ---- 4000/users/new 
-----------------------------------------------------------------------------------------------------
                    AUTHENTICATION SERVICE 
                    available throughout system
                    need to implement authentication as a plugs   
                      add it to router to be used by other routes 
                    (ex. after registration --> automatically logged in)
-----------------------------------
PLUG STRUCTURE 
  module plugs (init fun, call fun) vs function plugs
  ---------MODULE PLUG 
      defmodule APlug do
        def init(opts) do
          opts
        end
        def call(conn, _opts) do
          conn
        end
      end
      --------
      init ---- validate, transform opts
                result is _opts in call
                called in dev mode at runtime
                       in prod mode at compile time
      conn ----- data passed through every plug
                 has details for ev req  ---> until res 
      !!! all plugs:  conn --> conn --> conn    (Plug.Conn construct)
      ---------------------------
      Plug.Conn fields: 
          strings: 
                req fields: parsed by adapter for web server used (Cowboy by default in Phoenix)
                host ---- ex. www.lala.com
                method --- GET, POST, ...
                path_info ---  ex.  ["admin", "users"]
                scheme  ----- req protocol --- ex. :https 
          fetchable fields:
                cookies  ---- req cookies 
                params ------- req params parsed from query string
                                                 from req body 
          fields to process web reqs:
                assigns 
                halted  ----- to halt connection (ex. if auth failed)
          response fields: 
                resp_body  ---- initially empty, later ex. http res string
                resp_headers --- info about res type, caching rules, ...
                status --------- 200-299  --- success
                                 300-399 ---- redirects
                                 400-499 ---- bad client req (not found...)
                                 500+    ---- server errors 
          private fields (for adaptor, frameworks)
                adaptor  ----- info about underlying server 
                private -----  for private use of frameworks 

  ------------------------------------------------------------------------------------
  AUTHENTICATION PLUG 

  1. AUTH CONTROLLER (lib/rumble_web/controllers/auth.ex)

      defmodule RumblWeb.Auth do
        import Plug.Conn                                          !!! has assign fun 

        def init(opts), do: opts

        def call(conn, _opts) do
          user_id = get_session(conn, :user_id)                   !!! :user_id stored in session?
          user = user_id && Rumbl.Accounts.get_user(user_id)
          assign(conn, :current_user, user)                       !!! store result in nil or in conn.assign
        end
      end
      -----
      now :current_user accessed in all downstream funs (controllers, views, ...)
  ----------------------------
  2. ADD PLUG TO ROUTER (to end of pileline)

      defmodule RumbleWeb.Router do
        use RumbleWeb, :router

        pipeline :browser do
          plug :accepts, ["html"]
          plug :fetch_session
          plug :fetch_flash
          plug :protect_from_forgery
          plug :put_secure_browser_headers
          plug RumbleWeb.Auth                  ----- added 
        end
      ----
      plug Rumble.Auth    ---> adds :current_user to conn.assigns  in conn 
  -----------------------------
  3. access to :index, :show only if logged in: 
      USER CONTROLLER    ---- change index fun to be accessed for authenticated users only: 
         
        defmodule RumblWeb.UserController do
          use RumblWeb, :controller

          alias Rumbl.Accounts
          alias Rumbl.Accounts.User

          def index(conn, _params) do
            case authenticate(conn) do
              %Plug.Conn{halted: true} = conn ->
                conn

              conn ->
                users = Accounts.list_users()
                render(conn, "index.html", users: users)
            end
          end

          def show(conn, %{"id" => id}) do
            user = Accounts.get_user(id)
            render(conn, "show.html", user: user)
          end

          def new(conn, _params) do
            changeset = Accounts.change_registration(%User{}, %{})
            render(conn, "new.html", changeset: changeset)
          end

          def create(conn, %{"user" => user_params}) do
            case Accounts.register_user(user_params) do
              {:ok, user} ->
                conn
                |> RumblWeb.Auth.login(user)
                |> put_flash(:info, "#{user.name} created!")
                |> redirect(to: Routes.user_path(conn, :index))

              {:error, %Ecto.Changeset{} = changeset} ->
                render(conn, "new.html", changeset: changeset)
            end
          end

          defp authenticate(conn) do
            if conn.assigns.current_user do
              conn
            else
              conn
              |> put_flash(:error, "You must be logged in to access that page")
              |> redirect(to: Routes.page_path(conn, :index))
              |> halt()
            end
          end
        end 
          ------
          !!! if :current_user  --> returns conn unchanged
              if not            --> error message 
                                    redirect to root 
                                    halt.conn  --> stops all downstream transformations 

-------
4000/users    --> message -- must be logged in to access this page 
--------------------------------------------------------------
AVOID DRY (not to use same authenticate code for each action)  --- use pipeline 
    !!! change authenticate fun into function plug: 

    USER CONTROLLER    --- add 

       defmodule RumblWeb.UserController do
          use RumblWeb, :controller

          alias Rumbl.Accounts
          alias Rumbl.Accounts.User

          plug :authenticate when action in [:index, :show]

          def index(conn, _params) do
            users = Accounts.list_users()
            render(conn, "index.html", users: users)
          end

          def show(conn, %{"id" => id}) do
            user = Accounts.get_user(id)
            render(conn, "show.html", user: user)
          end

          def new(conn, _params) do
            changeset = Accounts.change_registration(%User{}, %{})
            render(conn, "new.html", changeset: changeset)
          end

          def create(conn, %{"user" => user_params}) do
            case Accounts.register_user(user_params) do
              {:ok, user} ->
                conn
                |> RumblWeb.Auth.login(user)
                |> put_flash(:info, "#{user.name} created!")
                |> redirect(to: Routes.user_path(conn, :index))

              {:error, %Ecto.Changeset{} = changeset} ->
                render(conn, "new.html", changeset: changeset)
            end
          end

          defp authenticate(conn, _opts) do
            if conn.assigns.current_user do
              conn
            else
              conn
              |> put_flash(:error, "You must be logged in to access that page")
              |> redirect(to: Routes.page_path(conn, :index))
              |> halt()
            end
          end
        end
        ----
        !!! plug explicitely checkes for halted: true 
------------------------------------------------------------
LOG IN USERS 
AUTH CONTROLLER       ---- add login fun 

    defmodule RumblWeb.Auth do
      import Plug.Conn

      def init(opts), do: opts

      def call(conn, _opts) do
        user_id = get_session(conn, :user_id)
        user = user_id && Rumbl.Accounts.get_user(user_id)
        assign(conn, :current_user, user)
      end

      def login(conn, user) do
        conn
        |> assign(:current_user, user)
        |> put_session(:user_id, user.id)       !!! puts current user.id into session
        |> configure_session(renew: true)       !!! configures session 
      end
    end
    -----
    Plug.Conn --- has field --- assigns 
                    setting a value --- assign 
    configure_session   ---- protects from session fixation attacks 
                             talls Plug to send session cookie back to client with dif identifier 
----------
4000/users/new  

---------------------------------------------------------------------------------------
IMPLEMENTING LOGIN, LOGOUT 
CONTEXT  --- ACCOUNTS 

    def authenticate_by_username_and_pass(username, given_pass) do
      user = get_user_by(username: username)

      cond do
        user && Pbkdf2.verify_pass(given_pass, user.password_hash) ->
          {:ok, user}                                                         !!! username + pw match

        user ->
          {:error, :unauthorized}                                             !!! wrong password 

        true ->
          Pbkdf2.no_user_verify()
          {:error, :not_found}                                                !!! no user with this username
      end
    end
    def get_user_by(params) do
      Repo.get_by(User, params)
    end
    -------
    !!! if user not found --> Comeonin's no_user_verify  
                                --> simulates password check with variable timing 
                                        against timing attacks
------------------------------------------------------------------------------------
ROUTER  ------ add sessioins routes 

    scope "/", RumblWeb do
      pipe_through :browser # Use the default browser stack

      get "/", PageController, :index
      resources "/users", UserController, only: [:index, :show, :new, :create]
      resources "/sessions", SessionController, only: [:new, :create, :delete]
    end

---------------------------------------------------------------------------------
CONTROLLER ---- SESSION  (lib/rumbl_web/controllers/session_controller.ex)

    defmodule RumblWeb.SessionController do
      use RumblWeb, :controller

      def new(conn, _) do
        render(conn, "new.html")
      end
    end
--------------------------------------------------------------------------------
VIEW (lib/rumbl_web/views/session_view.ex)

    defmodule RumblWeb.SessionView do
      use RumblWeb, :view
    end

------------------------------------------------------------------------------
TEMPLATE (lib/rumbl_web/templates/session/new.html.eex)

<h1>Login</h1>
<%= form_for @conn, Routes.session_path(@conn, :create), [as: :session], fn f -> %>
    <div><%= text_input f, :username, placeholder: "Username" %></div>
    <div><%= password_input f, :password, placeholder: "Password" %></div>
    <%= submit "Log in" %> 
<% end %>

------------
4000/sessions/new

----------------------------------------------------------------------------
USER ACCOUND LINKS IN LAYOUT 
(lib/rumbl_web/templates/layout/app.html.eex)

      <body>
        <header>
          <section class="container">
            <nav role="navigation">
              <ul>
                <%= if @current_user do %>
                  <li><%= @current_user.username %></li>
                  <li><%= link "Log out", to: Routes.session_path(@conn, :delete, @current_user), method: "delete" %></li>
                <% else %>
                  <li><%= link "Register", to: Routes.user_path(@conn, :new) %></li>
                  <li><%= link "Log in", to: Routes.session_path(@conn, :new) %></li>
                <% end %>
              </ul>
            </nav>
            
          </section>
        </header>
        <main role="main" class="container">
          <p class="alert alert-info" role="alert"><%= get_flash(@conn, :info) %></p>
          <p class="alert alert-danger" role="alert"><%= get_flash(@conn, :error) %></p>
          <%= @inner_content %>
        </main>
      </body>

--------------------------------------------------------------------------------------------
DELETE SESSION (LOGOUT)    
(lib/rumbl_web/controllers/auth.ex)    ---- add logout action 

    def logout(conn) do
      configure_session(conn, drop: true)
    end
--------------------------------------------------------------------
CONTROLLER ---- SESSION  (lib/rumbl_web/controllers/session_controller.ex)   --- add delete fun

    def delete(conn, _) do
      conn
      |> RumblWeb.Auth.logout()
      |> redirect(to: Routes.page_path(conn, :index))
    end




              