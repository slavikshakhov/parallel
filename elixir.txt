Elixir (transpile) -> Erlang (compile) -> BEAM 
                        
                            
                            SETUP 

install elixir 
> elixir -v


VSC extensions: 
    vscode-elixir
    vscode-elixir-formatter
    +- ElixirLS



**********************************************************************************************************
                            IEX (REPL)  >iex 

> i 'lala'          -> list  [108, 97, 108, 97]   ---- list of ASCII characters
> i "lala"          -> binary  <<108, 97, 108, 97>>
> i [1, 2, 3]       -> list
> i 2               -> gives info what 2 is (integer ... )        

> 4/2               -> 2 
> [:a, :b] ++ [1, 2, 3]        -> [:a, :b, 1, 2, 3]
> "lala" <> "tata"             -> "lalatata"
> String.downcase("LALA")      -> "lala"
> div 51, 2                    -> 25 
    > div a + b, 2             !!! where a and b passed as args 
> rem 51, 2                    -> 1 
> min 50, 6                    -> 6 
> IO.puts(5)                    -> like console.log(5)
> IO.puts "lala #{fun(5)}\n" 
  IO.puts ~s({lala "something"})   -> puts as message, sting in sting
  IO.puts ~s(#x {lala "something"})    !!! where x is var
> IO.gets "lala #{fun(5)}\n"    -> gets input from user -> feedback


> Enum.member?([1, 2, 3], 2)    -> true    !!! if arr contains el 
[1, 2, 3] |> Enum.each(fn el -> IO.puts(el) and) 
[1, 2, 3] |> Enum.reduce(0, fn x, y -> x + y end) 
[1, 2, 3] |> Enum.reduce(fn x, y -> x + y end)
["a", "b", "c"] |> Enum.zip([1, 2, 3])      --> [{"a", "1"}, {"b", 2}, {"c", 3}]   !!! check if same lentghs
%{"el1" => Enum.into(ar, %{})}
["a", "b", "c"] |> Enum.reduce(%{}, fn el, acc ->  Map.merge(acc, %{el => 5}) end)  -->  %{"a" => 5, "b" => 5, "c" => 5}
["a", "b", "c"] |> Enum.reduce(%{}, fn el, acc -> Map.put(acc, el, el) end)   -->  %{"a" => "a", "b" => "b", "c" => "c"}
["a", "b", "c"] |> Enum.zip([1, 2, 3]) |> Enum.into(%{})   ->  %{"a" => 1, "b" => 2, "c" => 3}
String.split(str, ~r{(\r\n|\r|\n)})   -> arr
[1, 2, 3] |> Enum.join(", ")     --> "1, 2, 3"
[1, 2, 3] |> Enum.each(fn el -> IO.gets("#{el}\n") |> String.trim  end)    -> ask for info for each el
 [1, 2, 3] |> Enum.map(fn x -> x*2 end)
 ["", "la", "ta"] |> Enum.filter(fn x -> x != "" end)    -> ["la", "ta"]
["a", "b", "c"] |> Enum.count  
[1, 2, 3, 4, 5] |> split(2)             -> {[1, 2], [3, 4, 5]}    ---- tuple
[1, 2, 3, 4, 5, 6] |> chunk(2)          -> [[1, 2], [3, 4], [5, 6]]  ----- array
ar = [1, 2, 3]     ------ [x, y | _tail] = ar
[1, 2] ++ [3, 4]                  -> [1, 2, 3, 4]
ar = [1, 2, 3, 4]  ----------- [h | t] = ar  -------- hd(ar)  ---- tl(ar)  ---- hd(tl(ar))


%{"a" => 5}
> Map.has_key?(%{a: 5, b: 8}, "a")   -> true   !!! if map contains key 
%{a: 5, b: 8} |> Map.keys
%{a: 5, b: 8} |> Map.values
> %{map | la: 50}                    -> updates existing key's value
> Map.merge(map1, %{:a => 32})       -> adds new key to map, if exists, updates ?  
Map.drop(m, ["la"])                     !!! first if has "la" key
m = %{a: 5, b: 6}   ---- m["a"]
%{x: val} =  %{x: 5, y: 8}    ----------  val ---  -> 5
Map.get(m, "a", "all")       --> val of "a"

 
double = fn x -> x*2 end    ------ double.(7)                      -> 14
def fun(x, y) when a > b do   .... end 
def fun(x, y) when a > b, do: fun2(y, x)


File.read(filename)         -> {:ok, body}   ------ body
                            -> {:error, reason} --- IO.puts(~s("#{:file.format_error(reason)}"\n))
File.write("filename.txt", "lala\ntata")        -> :ok  ------ "saved"
                                                -> {:error, reason} --- IO.puts(~s("#{:file.format_error(reason)}"\n))

 
str = """ lalala\n
             tata """
"LALA" |> String.downcase 
"lala\n" |> String.trim 
hash = :crypto.hash(:md5, "lala")     -> <<46, 56, 23, 41, 63, 194, 117, 219, 238, 116, 189, 113, 206, 110>>
Base.encode16(hash)                   -> "2E3817293FC275DBEE74BD71CE6EB056"
:binary.bin_to_list(hash)             -> [46, 56, 23, 41, 63, 194, 117, 219, 238, 116, 189, 113, 206, 110]


~r{....} 
    except words: [^\w]+   (1 or more, all)
    (la | ta)    match la or ta or both
    \\n          match \n 
    [^\w']+      (1 or more non word chars or apostrophy)  it's 


********************************************************************************************************

                                NEW PROJ (ex) ------ with module

new file ----- a.ex   

    defmodule A do
        def fun(x, y) do
            x + y
        end
    end
> c "a.ex"                  -> compiles 
> A.fun(5, 8)               -> 13

!!! > import A 
    > fun(5, 8)

---------------------------------------------------------------------------------------------------------
                                NEW PROJ (exs) ---- no module 

new file ----- a.exs 
> elixir a.exs 





---------------------------------------------------------------------
headers = ["activity", "when", "where"]
lines - ["clean, now, in the room", "work, tomorrow, at the office"]     
      -> 
      %{ "clean" => %{"when" => "now", "where" => "in the room" }, 
         "work" => %{"when" => "tomorrow", "where" => "at the office" }}

         Enum.reduce(lines, %{}, fn line, acc -> 
            [name | rest] = String.split(line, ",")
            if Enum.count(rest) == Enum.count(headers) do
                row = Enum.zip(headers, rest)                                 -> ar + ar = [obj, obj]
                      |> Enum.into(%{})                                       -> [obj, obj] -> {obj's k-v, obj's k-v}
                Map.merge(acc, %{name => row})                                -> {"a": {obj's k-v, obj's k-v}
            else 
                acc
            end 
         end
         ) 
 



    
